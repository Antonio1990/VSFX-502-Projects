<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Built-In Commands - expr manual page</title>
</head>
<body>
<table width='100%' border='0' cellspacing='0' cellpadding='0'
bgcolor='EAE2BB'>
<tr>
<td><a target='_blank' href=
'http://www.ActiveState.com/Products/ActiveTcl'><img src=
'../../images/ActiveTcl.gif' border='0' align='left' height='61'
width='64'></a> </td>
<td>
<div align='center' class='heading'>ActiveTcl User Guide</div>
</td>
<td><a target='_blank' href='http://www.ActiveState.com'><img src=
'../../images/AS_logo.gif' border='0' align='right' height='48'
width='112'></a> </td>
</tr>

<tr>
<td class='lineColour' colspan='3'></td>
</tr>
</table>

<br>
<dl>
<dd><a href="expr.htm#M2" name="L263">NAME</a> 

<dl>
<dd>expr - Evaluate an expression</dd>
</dl>
</dd>

<dd><a href="expr.htm#M3" name="L264">SYNOPSIS</a> 

<dl>
<dd><b>expr</b> <i>arg</i> ?<i>arg arg ...</i>?</dd>
</dl>
</dd>

<dd><a href="expr.htm#M4" name="L265">DESCRIPTION</a></dd>

<dd><a href="expr.htm#M5" name="L266">OPERANDS</a></dd>

<dd><a href="expr.htm#M6" name="L267">OPERATORS</a> 

<dl>
<dd><a href="expr.htm#M7" name="L268"><b>- + ~ !</b></a></dd>

<dd><a href="expr.htm#M8" name="L269"><b>* / %</b></a></dd>

<dd><a href="expr.htm#M9" name="L270"><b>+ -</b></a></dd>

<dd><a href="expr.htm#M10" name="L271"><b>&lt;&lt;
&gt;&gt;</b></a></dd>

<dd><a href="expr.htm#M11" name="L272"><b>&lt; &gt; &lt;=
&gt;=</b></a></dd>

<dd><a href="expr.htm#M12" name="L273"><b>== !=</b></a></dd>

<dd><a href="expr.htm#M13" name="L274"><b>eq ne</b></a></dd>

<dd><a href="expr.htm#M14" name="L275"><b>&amp;</b></a></dd>

<dd><a href="expr.htm#M15" name="L276"><b>^</b></a></dd>

<dd><a href="expr.htm#M16" name="L277"><b>|</b></a></dd>

<dd><a href="expr.htm#M17" name="L278"><b>&amp;&amp;</b></a></dd>

<dd><a href="expr.htm#M18" name="L279"><b>||</b></a></dd>

<dd><a href="expr.htm#M19" name=
"L280"><i>x</i><b>?</b><i>y</i><b>:</b><i>z</i></a></dd>
</dl>
</dd>

<dd><a href="expr.htm#M20" name="L281">MATH FUNCTIONS</a> 

<dl>
<dd><a href="expr.htm#M21" name=
"L282"><b>abs(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M22" name=
"L283"><b>acos(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M23" name=
"L284"><b>asin(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M24" name=
"L285"><b>atan(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M25" name="L286"><b>atan2(</b><i>y,
x</i><b>)</b></a></dd>

<dd><a href="expr.htm#M26" name=
"L287"><b>ceil(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M27" name=
"L288"><b>cos(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M28" name=
"L289"><b>cosh(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M29" name=
"L290"><b>double(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M30" name=
"L291"><b>exp(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M31" name=
"L292"><b>floor(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M32" name="L293"><b>fmod(</b><i>x,
y</i><b>)</b></a></dd>

<dd><a href="expr.htm#M33" name="L294"><b>hypot(</b><i>x,
y</i><b>)</b></a></dd>

<dd><a href="expr.htm#M34" name=
"L295"><b>int(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M35" name=
"L296"><b>log(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M36" name=
"L297"><b>log10(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M37" name="L298"><b>pow(</b><i>x,
y</i><b>)</b></a></dd>

<dd><a href="expr.htm#M38" name="L299"><b>rand()</b></a></dd>

<dd><a href="expr.htm#M39" name=
"L300"><b>round(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M40" name=
"L301"><b>sin(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M41" name=
"L302"><b>sinh(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M42" name=
"L303"><b>sqrt(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M43" name=
"L304"><b>srand(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M44" name=
"L305"><b>tan(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M45" name=
"L306"><b>tanh(</b><i>arg</i><b>)</b></a></dd>

<dd><a href="expr.htm#M46" name=
"L307"><b>wide(</b><i>arg</i><b>)</b></a></dd>
</dl>
</dd>

<dd><a href="expr.htm#M47" name="L308">TYPES, OVERFLOW, AND
PRECISION</a></dd>

<dd><a href="expr.htm#M48" name="L309">STRING OPERATIONS</a></dd>

<dd><a href="expr.htm#M49" name="L310">PERFORMANCE
CONSIDERATIONS</a></dd>

<dd><a href="expr.htm#M50" name="L311">SEE ALSO</a></dd>

<dd><a href="expr.htm#M51" name="L312">KEYWORDS</a></dd>
</dl>

<hr>
<h3><a name="M2">NAME</a></h3>

<p>expr - Evaluate an expression</p>

<h3><a name="M3">SYNOPSIS</a></h3>

<p><b>expr</b> <i>arg</i> ?<i>arg arg ...</i>?<br>
</p>

<h3><a name="M4">DESCRIPTION</a></h3>

<p>Concatenates <i>arg</i>'s (adding separator spaces between
them), evaluates the result as a Tcl expression, and returns the
value. The operators permitted in Tcl expressions are a subset of
the operators permitted in C expressions, and they have the same
meaning and precedence as the corresponding C operators.
Expressions almost always yield numeric results (integer or
floating-point values). For example, the expression</p>

<pre>
<b>expr 8.2 + 6</b>
</pre>

<p>evaluates to 14.2. Tcl expressions differ from C expressions in
the way that operands are specified. Also, Tcl expressions support
non-numeric operands and string comparisons.</p>

<h3><a name="M5">OPERANDS</a></h3>

<p>A Tcl expression consists of a combination of operands,
operators, and parentheses. White space may be used between the
operands and operators and parentheses; it is ignored by the
expression's instructions. Where possible, operands are interpreted
as integer values. Integer values may be specified in decimal (the
normal case), in octal (if the first character of the operand is
<b>0</b>), or in hexadecimal (if the first two characters of the
operand are <b>0x</b>). If an operand does not have one of the
integer formats given above, then it is treated as a floating-point
number if that is possible. Floating-point numbers may be specified
in any of the ways accepted by an ANSI-compliant C compiler (except
that the <b>f</b>, <b>F</b>, <b>l</b>, and <b>L</b> suffixes will
not be permitted in most installations). For example, all of the
following are valid floating-point numbers: 2.1, 3., 6e4, 7.91e+16.
If no numeric interpretation is possible, then an operand is left
as a string (and only a limited set of operators may be applied to
it).</p>

<p>On 32-bit systems, integer values MAX_INT (0x7FFFFFFF) and
MIN_INT (-0x80000000) will be represented as 32-bit values, and
integer values outside that range will be represented as 64-bit
values (if that is possible at all.)</p>

<p>Operands may be specified in any of the following ways:</p>

<dl>
<dt>[1]</dt>

<dd>As an numeric value, either integer or floating-point.</dd>

<dt>[2]</dt>

<dd>As a Tcl variable, using standard <b>$</b> notation. The
variable's value will be used as the operand.</dd>

<dt>[3]</dt>

<dd>As a string enclosed in double-quotes. The expression parser
will perform backslash, variable, and command substitutions on the
information between the quotes, and use the resulting value as the
operand</dd>

<dt>[4]</dt>

<dd>As a string enclosed in braces. The characters between the open
brace and matching close brace will be used as the operand without
any substitutions.</dd>

<dt>[5]</dt>

<dd>As a Tcl command enclosed in brackets. The command will be
executed and its result will be used as the operand.</dd>

<dt>[6]</dt>

<dd>As a mathematical function whose arguments have any of the
above forms for operands, such as <b>sin($x)</b>. See below for a
list of defined functions.</dd>
</dl>

<p>Where substitutions occur above (e.g. inside quoted strings),
they are performed by the expression's instructions. However, an
additional layer of substitution may already have been performed by
the command parser before the expression processor was called. As
discussed below, it is usually best to enclose expressions in
braces to prevent the command parser from performing substitutions
on the contents.</p>

<p>For some examples of simple expressions, suppose the variable
<b>a</b> has the value 3 and the variable <b>b</b> has the value 6.
Then the command on the left side of each of the lines below will
produce the value on the right side of the line:</p>

<pre>
<b>expr 3.1 + $a   6.1
expr 2 + "$a.$b"  5.6
expr 4*[llength "6 2"]    8
expr {{word one} &lt; "word $a"}  0</b>
</pre>

<h3><a name="M6">OPERATORS</a></h3>

<p>The valid operators are listed below, grouped in decreasing
order of precedence:</p>

<dl>
<dt><a name="M7"><b>- + ~ !</b></a></dt>

<dd>Unary minus, unary plus, bit-wise NOT, logical NOT. None of
these operands may be applied to string operands, and bit-wise NOT
may be applied only to integers.</dd>

<dt><a name="M8"><b>* / %</b></a></dt>

<dd>Multiply, divide, remainder. None of these operands may be
applied to string operands, and remainder may be applied only to
integers. The remainder will always have the same sign as the
divisor and an absolute value smaller than the divisor.</dd>

<dt><a name="M9"><b>+ -</b></a></dt>

<dd>Add and subtract. Valid for any numeric operands.</dd>

<dt><a name="M10"><b>&lt;&lt; &gt;&gt;</b></a></dt>

<dd>Left and right shift. Valid for integer operands only. A right
shift always propagates the sign bit.</dd>

<dt><a name="M11"><b>&lt; &gt; &lt;= &gt;=</b></a></dt>

<dd>Boolean less, greater, less than or equal, and greater than or
equal. Each operator produces 1 if the condition is true, 0
otherwise. These operators may be applied to strings as well as
numeric operands, in which case string comparison is used.</dd>

<dt><a name="M12"><b>== !=</b></a></dt>

<dd>Boolean equal and not equal. Each operator produces a zero/one
result. Valid for all operand types.</dd>

<dt><a name="M13"><b>eq ne</b></a></dt>

<dd>Boolean string equal and string not equal. Each operator
produces a zero/one result. The operand types are interpreted only
as strings.</dd>

<dt><a name="M14"><b>&amp;</b></a></dt>

<dd>Bit-wise AND. Valid for integer operands only.</dd>

<dt><a name="M15"><b>^</b></a></dt>

<dd>Bit-wise exclusive OR. Valid for integer operands only.</dd>

<dt><a name="M16"><b>|</b></a></dt>

<dd>Bit-wise OR. Valid for integer operands only.</dd>

<dt><a name="M17"><b>&amp;&amp;</b></a></dt>

<dd>Logical AND. Produces a 1 result if both operands are non-zero,
0 otherwise. Valid for boolean and numeric (integers or
floating-point) operands only.</dd>

<dt><a name="M18"><b>||</b></a></dt>

<dd>Logical OR. Produces a 0 result if both operands are zero, 1
otherwise. Valid for boolean and numeric (integers or
floating-point) operands only.</dd>

<dt><a name="M19"><i>x</i><b>?</b><i>y</i><b>:</b><i>z</i></a></dt>

<dd>If-then-else, as in C. If <i>x</i> evaluates to non-zero, then
the result is the value of <i>y</i>. Otherwise the result is the
value of <i>z</i>. The <i>x</i> operand must have a numeric
value.</dd>
</dl>

<p>See the C manual for more details on the results produced by
each operator. All of the binary operators group left-to-right
within the same precedence level. For example, the command</p>

<pre>
<b>expr 4*2 &lt; 7</b>
</pre>

<p>returns 0.</p>

<p>The <b>&amp;&amp;</b>, <b>||</b>, and <b>?:</b> operators have
``lazy evaluation'', just as in C, which means that operands are
not evaluated if they are not needed to determine the outcome. For
example, in the command</p>

<pre>
<b>expr {$v ? [a] : [b]}</b>
</pre>

<p>only one of <b>[a]</b> or <b>[b]</b> will actually be evaluated,
depending on the value of <b>$v</b>. Note, however, that this is
only true if the entire expression is enclosed in braces; otherwise
the Tcl parser will evaluate both <b>[a]</b> and <b>[b]</b> before
invoking the <b>expr</b> command.</p>

<h3><a name="M20">MATH FUNCTIONS</a></h3>

<p>Tcl supports the following mathematical functions in
expressions:</p>

<pre>
<b>abs</b> <b>cosh</b> <b>log</b>  <b>sqrt</b>
<b>acos</b> <b>double</b>   <b>log10</b>    <b>srand</b>
<b>asin</b> <b>exp</b>  <b>pow</b>  <b>tan</b>
<b>atan</b> <b>floor</b>    <b>rand</b> <b>tanh</b>
<b>atan2</b>    <b>fmod</b> <b>round</b>
<b>ceil</b> <b>hypot</b>    <b>sin</b>
<b>cos</b>  <b>int</b>  <b>sinh</b>
</pre>

<dl>
<dt><a name="M21"><b>abs(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the absolute value of <i>arg</i>. <i>Arg</i> may be
either integer or floating-point, and the result is returned in the
same form.</dd>

<dt><a name="M22"><b>acos(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the arc cosine of <i>arg</i>, in the range
[<i>0</i>,<i>pi</i>] radians. <i>Arg</i> should be in the range
[<i>-1</i>,<i>1</i>].</dd>

<dt><a name="M23"><b>asin(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the arc sine of <i>arg</i>, in the range
[<i>-pi/2</i>,<i>pi/2</i>] radians. <i>Arg</i> should be in the
range [<i>-1</i>,<i>1</i>].</dd>

<dt><a name="M24"><b>atan(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the arc tangent of <i>arg</i>, in the range
[<i>-pi/2</i>,<i>pi/2</i>] radians.</dd>

<dt><a name="M25"><b>atan2(</b><i>y, x</i><b>)</b></a></dt>

<dd>Returns the arc tangent of <i>y</i>/<i>x</i>, in the range
[<i>-pi</i>,<i>pi</i>] radians. <i>x</i> and <i>y</i> cannot both
be 0. If <i>x</i> is greater than <i>0</i>, this is equivalent to
<b>atan(</b><i>y/x</i><b>)</b>.</dd>

<dt><a name="M26"><b>ceil(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the smallest integral floating point value (i.e. with a
zero fractional part) not less than <i>arg</i>.</dd>

<dt><a name="M27"><b>cos(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the cosine of <i>arg</i>, measured in radians.</dd>

<dt><a name="M28"><b>cosh(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the hyperbolic cosine of <i>arg</i>. If the result
would cause an overflow, an error is returned.</dd>

<dt><a name="M29"><b>double(</b><i>arg</i><b>)</b></a></dt>

<dd>If <i>arg</i> is a floating value, returns <i>arg</i>,
otherwise converts <i>arg</i> to floating and returns the converted
value.</dd>

<dt><a name="M30"><b>exp(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the exponential of <i>arg</i>, defined as
<i>e</i>**<i>arg</i>. If the result would cause an overflow, an
error is returned.</dd>

<dt><a name="M31"><b>floor(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the largest integral floating point value (i.e. with a
zero fractional part) not greater than <i>arg</i>.</dd>

<dt><a name="M32"><b>fmod(</b><i>x, y</i><b>)</b></a></dt>

<dd>Returns the floating-point remainder of the division of
<i>x</i> by <i>y</i>. If <i>y</i> is 0, an error is returned.</dd>

<dt><a name="M33"><b>hypot(</b><i>x, y</i><b>)</b></a></dt>

<dd>Computes the length of the hypotenuse of a right-angled
triangle
<b>sqrt(</b><i>x</i>*<i>x</i>+<i>y</i>*<i>y</i><b>)</b>.</dd>

<dt><a name="M34"><b>int(</b><i>arg</i><b>)</b></a></dt>

<dd>If <i>arg</i> is an integer value, returns <i>arg</i>,
otherwise converts <i>arg</i> to an integer (of the same size as a
machine word, i.e. 32-bits on 32-bit systems, and 64-bits on 64-bit
systems) by truncation and returns the converted value.</dd>

<dt><a name="M35"><b>log(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the natural logarithm of <i>arg</i>. <i>Arg</i> must be
a positive value.</dd>

<dt><a name="M36"><b>log10(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the base 10 logarithm of <i>arg</i>. <i>Arg</i> must be
a positive value.</dd>

<dt><a name="M37"><b>pow(</b><i>x, y</i><b>)</b></a></dt>

<dd>Computes the value of <i>x</i> raised to the power <i>y</i>. If
<i>x</i> is negative, <i>y</i> must be an integer value.</dd>

<dt><a name="M38"><b>rand()</b></a></dt>

<dd>Returns a pseudo-random floating point value in the range
(<i>0</i>,<i>1</i>). The generator algorithm is a simple linear
congruential generator that is not cryptographically secure. Each
result from <b>rand</b> completely determines all future results
from subsequent calls to <b>rand</b>, so <b>rand</b> should not be
used to generate a sequence of secrets, such as one-time passwords.
The seed of the generator is initialized from the internal clock of
the machine or may be set with the <b>srand</b> function.</dd>

<dt><a name="M39"><b>round(</b><i>arg</i><b>)</b></a></dt>

<dd>If <i>arg</i> is an integer value, returns <i>arg</i>,
otherwise converts <i>arg</i> to integer by rounding and returns
the converted value.</dd>

<dt><a name="M40"><b>sin(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the sine of <i>arg</i>, measured in radians.</dd>

<dt><a name="M41"><b>sinh(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the hyperbolic sine of <i>arg</i>. If the result would
cause an overflow, an error is returned.</dd>

<dt><a name="M42"><b>sqrt(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the square root of <i>arg</i>. <i>Arg</i> must be
non-negative.</dd>

<dt><a name="M43"><b>srand(</b><i>arg</i><b>)</b></a></dt>

<dd>The <i>arg</i>, which must be an integer, is used to reset the
seed for the random number generator of <b>rand</b>. Returns the
first random number from that seed. Each interpreter has its own
seed.</dd>

<dt><a name="M44"><b>tan(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the tangent of <i>arg</i>, measured in radians.</dd>

<dt><a name="M45"><b>tanh(</b><i>arg</i><b>)</b></a></dt>

<dd>Returns the hyperbolic tangent of <i>arg</i>.</dd>

<dt><a name="M46"><b>wide(</b><i>arg</i><b>)</b></a></dt>

<dd>Converts <i>arg</i> to a value at least 64-bits wide (by
sign-extension if <i>arg</i> is a 32-bit number.)</dd>
</dl>

<p>In addition to these predefined functions, applications may
define additional functions using <b><a href=
"../TclLib/CrtMathFnc.htm">Tcl_CreateMathFunc</a></b>().</p>

<h3><a name="M47">TYPES, OVERFLOW, AND PRECISION</a></h3>

<p>All internal computations involving integers are done with the C
type <i>long</i>, and all internal computations involving
floating-point are done with the C type <i>double</i>. When
converting a string to floating-point, exponent overflow is
detected and results in a Tcl error. For conversion to integer from
string, detection of overflow depends on the behavior of some
routines in the local C library, so it should be regarded as
unreliable. In any case, integer overflow and underflow are
generally not detected reliably for intermediate results.
Floating-point overflow and underflow are detected to the degree
supported by the hardware, which is generally pretty reliable.</p>

<p>Conversion among internal representations for integer,
floating-point, and string operands is done automatically as
needed. For arithmetic computations, integers are used until some
floating-point number is introduced, after which floating-point is
used. For example,</p>

<pre>
<b>expr 5 / 4</b>
</pre>

<p>returns 1, while</p>

<pre>
<b>expr 5 / 4.0</b>
<b>expr 5 / ( [string length "abcd"] + 0.0 )</b>
</pre>

<p>both return 1.25. Floating-point values are always returned with
a ``<b>.</b>'' or an <b>e</b> so that they will not look like
integer values. For example,</p>

<pre>
<b>expr 20.0/5.0</b>
</pre>

<p>returns <b>4.0</b>, not <b>4</b>.</p>

<h3><a name="M48">STRING OPERATIONS</a></h3>

<p>String values may be used as operands of the comparison
operators, although the expression evaluator tries to do
comparisons as integer or floating-point when it can, except in the
case of the <b>eq</b> and <b>ne</b> operators. If one of the
operands of a comparison is a string and the other has a numeric
value, the numeric operand is converted back to a string using the
C <i>sprintf</i> format specifier <b>%d</b> for integers and
<b>%g</b> for floating-point values. For example, the commands</p>

<pre>
<b>expr {"0x03" &gt; "2"}</b>
<b>expr {"0y" &lt; "0x12"}</b>
</pre>

<p>both return 1. The first comparison is done using integer
comparison, and the second is done using string comparison after
the second operand is converted to the string <b>18</b>. Because of
Tcl's tendency to treat values as numbers whenever possible, it
isn't generally a good idea to use operators like <b>==</b> when
you really want string comparison and the values of the operands
could be arbitrary; it's better in these cases to use the <b>eq</b>
or <b>ne</b> operators, or the <b><a href=
"../TclCmd/string.htm">string</a></b> command instead.</p>

<h3><a name="M49">PERFORMANCE CONSIDERATIONS</a></h3>

<p>Enclose expressions in braces for the best speed and the
smallest storage requirements. This allows the Tcl bytecode
compiler to generate the best code.</p>

<p>As mentioned above, expressions are substituted twice: once by
the Tcl parser and once by the <b>expr</b> command. For example,
the commands</p>

<pre>
<b>set a 3</b>
<b>set b {$a + 2}</b>
<b>expr $b*4</b>
</pre>

<p>return 11, not a multiple of 4. This is because the Tcl parser
will first substitute <b>$a + 2</b> for the variable <b>b</b>, then
the <b>expr</b> command will evaluate the expression <b>$a +
2*4</b>.</p>

<p>Most expressions do not require a second round of substitutions.
Either they are enclosed in braces or, if not, their variable and
command substitutions yield numbers or strings that don't
themselves require substitutions. However, because a few unbraced
expressions need two rounds of substitutions, the bytecode compiler
must emit additional instructions to handle this situation. The
most expensive code is required for unbraced expressions that
contain command substitutions. These expressions must be
implemented by generating new code each time the expression is
executed.</p>

<h3><a name="M50">SEE ALSO</a></h3>

<p><b><a href="../TclCmd/array.htm">array</a></b>, <b><a href=
"../TclCmd/string.htm">string</a></b>, <b><a href=
"../TclCmd/Tcl.htm">Tcl</a></b></p>

<h3><a name="M51">KEYWORDS</a></h3>

<p><a href="../Keywords/A.htm#arithmetic">arithmetic</a>, <a href=
"../Keywords/B.htm#boolean">boolean</a>, <a href=
"../Keywords/C.htm#compare">compare</a>, <a href=
"../Keywords/E.htm#expression">expression</a>, <a href=
"../Keywords/F.htm#fuzzy comparison">fuzzy comparison</a></p>

<hr>
<pre>
<a href=
"../copyright.htm">Copyright</a> &copy; 1993 The Regents of the University of California.
<a href=
"../copyright.htm">Copyright</a> &copy; 1994-2000 Sun Microsystems, Inc.
<a href=
"../copyright.htm">Copyright</a> &copy; 1995-1997 Roger E. Critchlow Jr.
</pre>
</body>
</html>

