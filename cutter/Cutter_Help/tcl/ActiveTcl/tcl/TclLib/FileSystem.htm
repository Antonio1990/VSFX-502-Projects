<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta name='Author' content='ActiveState'>
<link rel='stylesheet' type='text/css' href='../../aspn.css'>
<title>Tcl Library Procedures - Filesystem manual page</title>
</head>
<body>
<table width='100%' border='0' cellspacing='0' cellpadding='0'
bgcolor='EAE2BB'>
<tr>
<td><a target='_blank' href=
'http://www.ActiveState.com/Products/ActiveTcl'><img src=
'../../images/ActiveTcl.gif' border='0' align='left' height='61'
width='64'></a> </td>
<td>
<div align='center' class='heading'>ActiveTcl User Guide</div>
</td>
<td><a target='_blank' href='http://www.ActiveState.com'><img src=
'../../images/AS_logo.gif' border='0' align='right' height='48'
width='112'></a> </td>
</tr>

<tr>
<td class='lineColour' colspan='3'></td>
</tr>
</table>

<br>
<dl>
<dd><a href="FileSystem.htm#M2" name="L253">NAME</a> 

<dl>
<dd>Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData,
Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType,
Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory,
Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile,
Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSLoadFile,
Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime,
Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings,
Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd,
Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath,
Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath,
Tcl_FSConvertToPathType, Tcl_FSGetInternalRep,
Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath,
Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo,
Tcl_AllocStatBuf - procedures to interact with any filesystem</dd>
</dl>
</dd>

<dd><a href="FileSystem.htm#M3" name="L254">SYNOPSIS</a></dd>

<dd><a href="FileSystem.htm#M4" name="L255">ARGUMENTS</a></dd>

<dd><a href="FileSystem.htm#M5" name="L256">DESCRIPTION</a></dd>

<dd><a href="FileSystem.htm#M6" name="L257">TCL_FILESYSTEM</a></dd>

<dd><a href="FileSystem.htm#M7" name="L258">TYPENAME</a></dd>

<dd><a href="FileSystem.htm#M8" name="L259">STRUCTURE
LENGTH</a></dd>

<dd><a href="FileSystem.htm#M9" name="L260">VERSION</a></dd>

<dd><a href="FileSystem.htm#M10" name="L261">FILESYSTEM
INFRASTRUCTURE</a></dd>

<dd><a href="FileSystem.htm#M11" name=
"L262">PATHINFILESYSTEMPROC</a></dd>

<dd><a href="FileSystem.htm#M12" name=
"L263">DUPINTERNALREPPROC</a></dd>

<dd><a href="FileSystem.htm#M13" name=
"L264">FREEINTERNALREPPROC</a></dd>

<dd><a href="FileSystem.htm#M14" name=
"L265">INTERNALTONORMALIZEDPROC</a></dd>

<dd><a href="FileSystem.htm#M15" name=
"L266">CREATEINTERNALREPPROC</a></dd>

<dd><a href="FileSystem.htm#M16" name=
"L267">NORMALIZEPATHPROC</a></dd>

<dd><a href="FileSystem.htm#M17" name="L268">FILESYSTEM
OPERATIONS</a></dd>

<dd><a href="FileSystem.htm#M18" name=
"L269">FILESYSTEMPATHTYPEPROC</a></dd>

<dd><a href="FileSystem.htm#M19" name=
"L270">FILESYSTEMSEPARATORPROC</a></dd>

<dd><a href="FileSystem.htm#M20" name="L271">STATPROC</a></dd>

<dd><a href="FileSystem.htm#M21" name="L272">ACCESSPROC</a></dd>

<dd><a href="FileSystem.htm#M22" name=
"L273">OPENFILECHANNELPROC</a></dd>

<dd><a href="FileSystem.htm#M23" name=
"L274">MATCHINDIRECTORYPROC</a></dd>

<dd><a href="FileSystem.htm#M24" name="L275">UTIMEPROC</a></dd>

<dd><a href="FileSystem.htm#M25" name="L276">LINKPROC</a></dd>

<dd><a href="FileSystem.htm#M26" name=
"L277">LISTVOLUMESPROC</a></dd>

<dd><a href="FileSystem.htm#M27" name=
"L278">FILEATTRSTRINGSPROC</a></dd>

<dd><a href="FileSystem.htm#M28" name=
"L279">FILEATTRSGETPROC</a></dd>

<dd><a href="FileSystem.htm#M29" name=
"L280">FILEATTRSSETPROC</a></dd>

<dd><a href="FileSystem.htm#M30" name=
"L281">CREATEDIRECTORYPROC</a></dd>

<dd><a href="FileSystem.htm#M31" name=
"L282">REMOVEDIRECTORYPROC</a></dd>

<dd><a href="FileSystem.htm#M32" name=
"L283">DELETEFILEPROC</a></dd>

<dd><a href="FileSystem.htm#M33" name="L284">FILESYSTEM
EFFICIENCY</a></dd>

<dd><a href="FileSystem.htm#M34" name="L285">LSTATPROC</a></dd>

<dd><a href="FileSystem.htm#M35" name="L286">COPYFILEPROC</a></dd>

<dd><a href="FileSystem.htm#M36" name=
"L287">RENAMEFILEPROC</a></dd>

<dd><a href="FileSystem.htm#M37" name=
"L288">COPYDIRECTORYPROC</a></dd>

<dd><a href="FileSystem.htm#M38" name="L289">LOADFILEPROC</a></dd>

<dd><a href="FileSystem.htm#M39" name=
"L290">UNLOADFILEPROC</a></dd>

<dd><a href="FileSystem.htm#M40" name="L291">GETCWDPROC</a></dd>

<dd><a href="FileSystem.htm#M41" name="L292">CHDIRPROC</a></dd>

<dd><a href="FileSystem.htm#M42" name="L293">KEYWORDS</a></dd>
</dl>

<hr>
<h3><a name="M2">NAME</a></h3>

<p>Tcl_FSRegister, Tcl_FSUnregister, Tcl_FSData,
Tcl_FSMountsChanged, Tcl_FSGetFileSystemForPath, Tcl_FSGetPathType,
Tcl_FSCopyFile, Tcl_FSCopyDirectory, Tcl_FSCreateDirectory,
Tcl_FSDeleteFile, Tcl_FSRemoveDirectory, Tcl_FSRenameFile,
Tcl_FSListVolumes, Tcl_FSEvalFile, Tcl_FSLoadFile,
Tcl_FSMatchInDirectory, Tcl_FSLink, Tcl_FSLstat, Tcl_FSUtime,
Tcl_FSFileAttrsGet, Tcl_FSFileAttrsSet, Tcl_FSFileAttrStrings,
Tcl_FSStat, Tcl_FSAccess, Tcl_FSOpenFileChannel, Tcl_FSGetCwd,
Tcl_FSChdir, Tcl_FSPathSeparator, Tcl_FSJoinPath, Tcl_FSSplitPath,
Tcl_FSEqualPaths, Tcl_FSGetNormalizedPath, Tcl_FSJoinToPath,
Tcl_FSConvertToPathType, Tcl_FSGetInternalRep,
Tcl_FSGetTranslatedPath, Tcl_FSGetTranslatedStringPath,
Tcl_FSNewNativePath, Tcl_FSGetNativePath, Tcl_FSFileSystemInfo,
Tcl_AllocStatBuf - procedures to interact with any filesystem</p>

<h3><a name="M3">SYNOPSIS</a></h3>

<p><b>#include &lt;tcl.h&gt;</b><br>
int<br>
<b>Tcl_FSRegister</b>(<i>clientData, fsPtr</i>)<br>
int<br>
<b>Tcl_FSUnregister</b>(<i>fsPtr</i>)<br>
ClientData<br>
<b>Tcl_FSData</b>(<i>fsPtr</i>)<br>
void<br>
<b>Tcl_FSMountsChanged</b>(<i>fsPtr</i>)<br>
Tcl_Filesystem*<br>
<b>Tcl_FSGetFileSystemForPath</b>(<i>pathObjPtr</i>)<br>
Tcl_PathType<br>
<b>Tcl_FSGetPathType</b>(<i>pathObjPtr</i>)<br>
int<br>
<b>Tcl_FSCopyFile</b>(<i>srcPathPtr, destPathPtr</i>)<br>
int<br>
<b>Tcl_FSCopyDirectory</b>(<i>srcPathPtr, destPathPtr,
errorPtr</i>)<br>
int<br>
<b>Tcl_FSCreateDirectory</b>(<i>pathPtr</i>)<br>
int<br>
<b>Tcl_FSDeleteFile</b>(<i>pathPtr</i>)<br>
int<br>
<b>Tcl_FSRemoveDirectory</b>(<i>pathPtr, int recursive,
errorPtr</i>)<br>
int<br>
<b>Tcl_FSRenameFile</b>(<i>srcPathPtr, destPathPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSListVolumes</b>(<i>void</i>)<br>
int<br>
<b>Tcl_FSEvalFile</b>(<i>interp, pathPtr</i>)<br>
int<br>
<b>Tcl_FSLoadFile</b>(<i>interp, pathPtr, sym1, sym2, proc1Ptr,
proc2Ptr, handlePtr, unloadProcPtr</i>)<br>
int<br>
<b>Tcl_FSMatchInDirectory</b>(<i>interp, result, pathPtr, pattern,
types</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSLink</b>(<i>linkNamePtr, toPtr, linkAction</i>)<br>
int<br>
<b>Tcl_FSLstat</b>(<i>pathPtr, statPtr</i>)<br>
int<br>
<b>Tcl_FSUtime</b>(<i>pathPtr, tval</i>)<br>
int<br>
<b>Tcl_FSFileAttrsGet</b>(<i>interp, int index, pathPtr,
objPtrRef</i>)<br>
int<br>
<b>Tcl_FSFileAttrsSet</b>(<i>interp, int index, pathPtr, Tcl_Obj
*objPtr</i>)<br>
CONST char**<br>
<b>Tcl_FSFileAttrStrings</b>(<i>pathPtr, objPtrRef</i>)<br>
int<br>
<b>Tcl_FSStat</b>(<i>pathPtr, statPtr</i>)<br>
int<br>
<b>Tcl_FSAccess</b>(<i>pathPtr, mode</i>)<br>
Tcl_Channel<br>
<b>Tcl_FSOpenFileChannel</b>(<i>interp, pathPtr, modeString,
permissions</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSGetCwd</b>(<i>interp</i>)<br>
int<br>
<b>Tcl_FSChdir</b>(<i>pathPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSPathSeparator</b>(<i>pathPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSJoinPath</b>(<i>listObj, elements</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSSplitPath</b>(<i>pathPtr, lenPtr</i>)<br>
int<br>
<b>Tcl_FSEqualPaths</b>(<i>firstPtr, secondPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSGetNormalizedPath</b>(<i>interp, pathPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSJoinToPath</b>(<i>basePtr, objc, objv</i>)<br>
int<br>
<b>Tcl_FSConvertToPathType</b>(<i>interp, pathPtr</i>)<br>
ClientData<br>
<b>Tcl_FSGetInternalRep</b>(<i>pathPtr, fsPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSGetTranslatedPath</b>(<i>interp, pathPtr</i>)<br>
CONST char*<br>
<b>Tcl_FSGetTranslatedStringPath</b>(<i>interp, pathPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSNewNativePath</b>(<i>fsPtr, clientData</i>)<br>
CONST char*<br>
<b>Tcl_FSGetNativePath</b>(<i>pathPtr</i>)<br>
Tcl_Obj*<br>
<b>Tcl_FSFileSystemInfo</b>(<i>pathPtr</i>)<br>
Tcl_StatBuf*<br>
<b>Tcl_AllocStatBuf</b>()<br>
</p>

<h3><a name="M4">ARGUMENTS</a></h3>

<dl>
<dt>Tcl_Filesystem <b>*fsPtr</b> (in)</dt>

<dd>Points to a structure containing the addresses of procedures
that can be called to perform the various filesystem
operations.</dd>

<dt>Tcl_Obj <b>*pathPtr</b> (in)</dt>

<dd>The path represented by this object is used for the operation
in question. If the object does not already have an internal
<b>path</b> representation, it will be converted to have one.</dd>

<dt>Tcl_Obj <b>*srcPathPtr</b> (in)</dt>

<dd>As for <b>pathPtr</b>, but used for the source file for a copy
or rename operation.</dd>

<dt>Tcl_Obj <b>*destPathPtr</b> (in)</dt>

<dd>As for <b>pathPtr</b>, but used for the destination filename
for a copy or rename operation.</dd>

<dt>CONST char <b>*pattern</b> (in)</dt>

<dd>Only files or directories matching this pattern will be
returned by <b>Tcl_FSMatchInDirectory</b>.</dd>

<dt>GlobTypeData <b>*types</b> (in)</dt>

<dd>Only files or directories matching the type descriptions
contained in this structure will be returned by
<b>Tcl_FSMatchInDirectory</b>. It is very important that the
'directory' flag is properly handled. This parameter may be
NULL.</dd>

<dt><a href="../TclLib/Interp.htm">Tcl_Interp</a> <b>*interp</b>
(in)</dt>

<dd>Interpreter to use either for results, evaluation, or reporting
error messages.</dd>

<dt>ClientData <b>clientData</b> (in)</dt>

<dd>The native description of the path object to create.</dd>

<dt>Tcl_Obj <b>*firstPtr</b> (in)</dt>

<dd>The first of two path objects to compare. The object may be
converted to <b>path</b> type.</dd>

<dt>Tcl_Obj <b>*secondPtr</b> (in)</dt>

<dd>The second of two path objects to compare. The object may be
converted to <b>path</b> type.</dd>

<dt>Tcl_Obj <b>*listObj</b> (in)</dt>

<dd>The list of path elements to operate on with a <b><a href=
"../TclCmd/join.htm">join</a></b> operation.</dd>

<dt>int <b>elements</b> (in)</dt>

<dd>If non-negative, the number of elements in the listObj which
should be joined together. If negative, then all elements are
joined.</dd>

<dt>Tcl_Obj <b>**errorPtr</b> (out)</dt>

<dd>In the case of an error, filled with an object containing the
name of the file which caused an error in the various copy/rename
operations.</dd>

<dt>Tcl_Obj <b>**objPtrRef</b> (out)</dt>

<dd>Filled with an object containing the result of the
operation.</dd>

<dt>Tcl_Obj <b>*result</b> (out)</dt>

<dd>Pre-allocated object in which to store (by lappending) the list
of files or directories which are successfully matched in
<b>Tcl_FSMatchInDirectory</b>.</dd>

<dt>int <b>mode</b> (in)</dt>

<dd>Mask consisting of one or more of R_OK, W_OK, X_OK and F_OK.
R_OK, W_OK and X_OK request checking whether the file exists and
has read, write and execute permissions, respectively. F_OK just
requests checking for the existence of the file.</dd>

<dt>Tcl_StatBuf <b>*statPtr</b> (out)</dt>

<dd>The structure that contains the result of a stat or lstat
operation.</dd>

<dt>CONST char <b>*sym1</b> (in)</dt>

<dd>Name of a procedure to look up in the file's symbol table</dd>

<dt>CONST char <b>*sym2</b> (in)</dt>

<dd>Name of a procedure to look up in the file's symbol table</dd>

<dt>Tcl_PackageInitProc <b>**proc1Ptr</b> (out)</dt>

<dd>Filled with the init function for this code.</dd>

<dt>Tcl_PackageInitProc <b>**proc2Ptr</b> (out)</dt>

<dd>Filled with the safe-init function for this code.</dd>

<dt>ClientData <b>*clientDataPtr</b> (out)</dt>

<dd>Filled with the clientData value to pass to this code's unload
function when it is called.</dd>

<dt>TclfsUnloadFileProc_ <b>**unloadProcPtr</b> (out)</dt>

<dd>Filled with the function to use to unload this piece of
code.</dd>

<dt>utimbuf <b>*tval</b> (in)</dt>

<dd>The access and modification times in this structure are read
and used to set those values for a given file.</dd>

<dt>CONST char <b>*modeString</b> (in)</dt>

<dd>Specifies how the file is to be accessed. May have any of the
values allowed for the <i>mode</i> argument to the Tcl <b><a href=
"../TclCmd/open.htm">open</a></b> command.</dd>

<dt>int <b>permissions</b> (in)</dt>

<dd>POSIX-style permission flags such as 0644. If a new file is
created, these permissions will be set on the created file.</dd>

<dt>int <b>*lenPtr</b> (out)</dt>

<dd>If non-NULL, filled with the number of elements in the split
path.</dd>

<dt>Tcl_Obj <b>*basePtr</b> (in)</dt>

<dd>The base path on to which to join the given elements. May be
NULL.</dd>

<dt>int <b>objc</b> (in)</dt>

<dd>The number of elements in <i>objv</i>.</dd>

<dt>Tcl_Obj *CONST <b>objv[]</b> (in)</dt>

<dd>The elements to join to the given base path.</dd>
</dl>

<h3><a name="M5">DESCRIPTION</a></h3>

<p>There are several reasons for calling the <b>Tcl_FS...</b>
functions rather than calling system level functions like
<b>access</b> and <b>stat</b> directly. First, they will work
cross-platform, so an extension which calls them should work
unmodified on Unix, MacOS and Windows. Second, the Windows
implementation of some of these functions fixes some bugs in the
system level calls. Third, these function calls deal with any 'Utf
to platform-native' path conversions which may be required (and may
cache the results of such conversions for greater efficiency on
subsequent calls). Fourth, and perhaps most importantly, all of
these functions are 'virtual filesystem aware'. Any virtual
filesystem which has been registered (through
<b>Tcl_FSRegister</b>) may reroute file access to alternative media
or access methods. This means that all of these functions (and
therefore the corresponding <b><a href=
"../TclCmd/file.htm">file</a></b>, <b><a href=
"../TclCmd/glob.htm">glob</a></b>, <b><a href=
"../TclCmd/pwd.htm">pwd</a></b>, <b><a href=
"../TclCmd/cd.htm">cd</a></b>, <b><a href=
"../TclCmd/open.htm">open</a></b>, etc. Tcl commands) may be
operate on 'files' which are not native files in the native
filesystem. This also means that any Tcl extension which accesses
the filesystem through this API is automatically 'virtual
filesystem aware'. Of course, if an extension accesses the native
filesystem directly (through platform-specific APIs, for example),
then Tcl cannot intercept such calls.</p>

<p>If appropriate vfs's have been registered, the 'files' may, to
give two examples, be remote (e.g. situated on a remote ftp server)
or archived (e.g. lying inside a .zip archive). Such registered
filesystems provide a lookup table of functions to implement all or
some of the functionality listed here. Finally, the
<b>Tcl_FSStat</b> and <b>Tcl_FSLstat</b> calls abstract away from
what the 'struct stat' buffer buffer is actually declared to be,
allowing the same code to be used both on systems with and systems
without support for files larger than 2GB in size.</p>

<p>The <b>Tcl_FS...</b> are objectified and may cache internal
representations and other path-related strings (e.g. the current
working directory). One side-effect of this is that one must not
pass in objects with a refCount of zero to any of these functions.
If such calls were handled, they might result in memory leaks
(under some circumstances, the filesystem code may wish to retain a
reference to the passed in object, and so one must not assume that
after any of these calls return, the object still has a refCount of
zero - it may have been incremented), or in a direct segfault due
to the object being freed part way through the complex object
manipulation required to ensure that the path is fully normalized
and absolute for filesystem determination. The practical lesson to
learn from this is that <b>Tcl_Obj *path = Tcl_NewStringObj(...) ;
Tcl_FS...(path) ; Tcl_DecrRefCount(path)</b> is wrong, and may
segfault. The 'path' must have its refCount incremented before
passing it in, or decrementing it. For this reason, objects with a
refCount of zero are considered not to be valid filesystem paths
and calling any Tcl_FS API with such an object will result in no
action being taken.</p>

<p><b>Tcl_FSCopyFile</b> attempts to copy the file given by
srcPathPtr to the path name given by destPathPtr. If the two paths
given lie in the same filesystem (according to
<b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's 'copy
file' function is called (if it is non-NULL). Otherwise the
function returns -1 and sets Tcl's errno to the 'EXDEV' posix error
code (which signifies a 'cross-domain link').</p>

<p><b>Tcl_FSCopyDirectory</b> attempts to copy the directory given
by srcPathPtr to the path name given by destPathPtr. If the two
paths given lie in the same filesystem (according to
<b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's 'copy
file' function is called (if it is non-NULL). Otherwise the
function returns -1 and sets Tcl's errno to the 'EXDEV' posix error
code (which signifies a 'cross-domain link').</p>

<p><b>Tcl_FSCreateDirectory</b> attempts to create the directory
given by pathPtr by calling the owning filesystem's 'create
directory' function.</p>

<p><b>Tcl_FSDeleteFile</b> attempts to delete the file given by
pathPtr by calling the owning filesystem's 'delete file'
function.</p>

<p><b>Tcl_FSRemoveDirectory</b> attempts to remove the directory
given by pathPtr by calling the owning filesystem's 'remove
directory' function.</p>

<p><b>Tcl_FSRenameFile</b> attempts to rename the file or directory
given by srcPathPtr to the path name given by destPathPtr. If the
two paths given lie in the same filesystem (according to
<b>Tcl_FSGetFileSystemForPath</b>) then that filesystem's 'rename
file' function is called (if it is non-NULL). Otherwise the
function returns -1 and sets Tcl's errno to the 'EXDEV' posix error
code (which signifies a ``cross-domain link'').</p>

<p><b>Tcl_FSListVolumes</b> calls each filesystem which has a
non-NULL 'list volumes' function and asks them to return their list
of root volumes. It accumulates the return values in a list which
is returned to the caller (with a refCount of 0).</p>

<p><b>Tcl_FSEvalFile</b> reads the file given by <i>pathPtr</i> and
evaluates its contents as a Tcl script. It returns the same
information as <b><a href=
"../TclLib/Eval.htm">Tcl_EvalObjEx</a></b>. If the file couldn't be
read then a Tcl error is returned to describe why the file couldn't
be read. The eofchar for files is '\32' (^Z) for all platforms. If
you require a ``^Z'' in code for string comparison, you can use
``\032'' or ``\u001a'', which will be safely substituted by the Tcl
interpreter into ``^Z''.</p>

<p><b>Tcl_FSLoadFile</b> dynamically loads a binary code file into
memory and returns the addresses of two procedures within that
file, if they are defined. The appropriate function for the
filesystem to which pathPtr belongs will be called. If that
filesystem does not implement this function (most virtual
filesystems will not, because of OS limitations in dynamically
loading binary code), Tcl will attempt to copy the file to a
temporary directory and load that temporary file.</p>

<p>Returns a standard Tcl completion code. If an error occurs, an
error message is left in the interp's result.</p>

<p><b>Tcl_FSMatchInDirectory</b> is used by the globbing code to
search a directory for all files which match a given pattern. The
appropriate function for the filesystem to which pathPtr belongs
will be called.</p>

<p>The return value is a standard Tcl result indicating whether an
error occurred in globbing. Error messages are placed in interp,
but good results are placed in the resultPtr given. Note that the
'glob' code implements recursive patterns internally, so this
function will only ever be passed simple patterns, which can be
matched using the logic of 'string match'. To handle recursion, Tcl
will call this function frequently asking only for directories to
be returned.</p>

<p><b>Tcl_FSLink</b> replaces the library version of readlink(),
and extends it to support the creation of links. The appropriate
function for the filesystem to which linkNamePtr belongs will be
called.</p>

<p>If the <i>toPtr</i> is NULL, a readlink action is performed. The
result is a Tcl_Obj specifying the contents of the symbolic link
given by <i>linkNamePtr</i>, or NULL if the link could not be read.
The result is owned by the caller, which should call <a href=
"../TclLib/Object.htm">Tcl_DecrRefCount</a> when the result is no
longer needed. If the <i>toPtr</i> is not NULL, Tcl should create a
link of one of the types passed in in the <i>linkAction</i> flag.
This flag is an or'd combination of TCL_CREATE_SYMBOLIC_LINK and
TCL_CREATE_HARD_LINK. Where a choice exists (i.e. more than one
flag is passed in), the Tcl convention is to prefer symbolic links.
When a link is successfully created, the return value should be
<i>toPtr</i> (which is therefore already owned by the caller). If
unsuccessful, NULL should be returned.</p>

<p><b>Tcl_FSLstat</b> fills the stat structure <i>statPtr</i> with
information about the specified file. You do not need any access
rights to the file to get this information but you need search
rights to all directories named in the path leading to the file.
The stat structure includes info regarding device, inode (always 0
on Windows), privilege mode, nlink (always 1 on Windows), user id
(always 0 on Windows), group id (always 0 on Windows), rdev (same
as device on Windows), size, last access time, last modification
time, and creation time.</p>

<p>If <i>path</i> exists, <b>Tcl_FSLstat</b> returns 0 and the stat
structure is filled with data. Otherwise, -1 is returned, and no
stat info is given.</p>

<p><b>Tcl_FSUtime</b> replaces the library version of utime.</p>

<p>For results see 'utime' documentation. If successful, the
function will update the 'atime' and 'mtime' values of the file
given.</p>

<p><b>Tcl_FSFileAttrsGet</b> implements read access for the
hookable 'file attributes' subcommand. The appropriate function for
the filesystem to which pathPtr belongs will be called.</p>

<p>If the result is TCL_OK, then an object was placed in objPtrRef,
which will only be temporarily valid (unless <a href=
"../TclLib/Object.htm">Tcl_IncrRefCount</a> is called).</p>

<p><b>Tcl_FSFileAttrsSet</b> implements write access for the
hookable 'file attributes' subcommand. The appropriate function for
the filesystem to which pathPtr belongs will be called.</p>

<p><b>Tcl_FSFileAttrStrings</b> implements part of the hookable
'file attributes' subcommand. The appropriate function for the
filesystem to which pathPtr belongs will be called.</p>

<p>The called procedure may either return an array of strings, or
may instead return NULL and place a Tcl list into the given
objPtrRef. Tcl will take that list and first increment its refCount
before using it. On completion of that use, Tcl will decrement its
refCount. Hence if the list should be disposed of by Tcl when done,
it should have a refCount of zero, and if the list should not be
disposed of, the filesystem should ensure it retains a refCount on
the object.</p>

<p><b>Tcl_FSAccess</b> checks whether the process would be allowed
to read, write or test for existence of the file (or other file
system object) whose name is pathname. If pathname is a symbolic
link on Unix, then permissions of the file referred by this
symbolic link are tested.</p>

<p>On success (all requested permissions granted), zero is
returned. On error (at least one bit in mode asked for a permission
that is denied, or some other error occurred), -1 is returned.</p>

<p><b>Tcl_FSStat</b> fills the stat structure <i>statPtr</i> with
information about the specified file. You do not need any access
rights to the file to get this information but you need search
rights to all directories named in the path leading to the file.
The stat structure includes info regarding device, inode (always 0
on Windows), privilege mode, nlink (always 1 on Windows), user id
(always 0 on Windows), group id (always 0 on Windows), rdev (same
as device on Windows), size, last access time, last modification
time, and creation time.</p>

<p>If <i>path</i> exists, <b>Tcl_FSStat</b> returns 0 and the stat
structure is filled with data. Otherwise, -1 is returned, and no
stat info is given.</p>

<p><b>Tcl_FSOpenFileChannel</b> opens a file specified by
<i>pathPtr</i> and returns a channel handle that can be used to
perform input and output on the file. This API is modeled after the
<b>fopen</b> procedure of the Unix standard I/O library. The syntax
and meaning of all arguments is similar to those given in the Tcl
<b><a href="../TclCmd/open.htm">open</a></b> command when opening a
file. If an error occurs while opening the channel,
<b>Tcl_FSOpenFileChannel</b> returns NULL and records a POSIX error
code that can be retrieved with <b><a href=
"../TclLib/SetErrno.htm">Tcl_GetErrno</a></b>. In addition, if
<i>interp</i> is non-NULL, <b>Tcl_FSOpenFileChannel</b> leaves an
error message in <i>interp</i>'s result after any error.</p>

<p>The newly created channel is not registered in the supplied
interpreter; to register it, use <b><a href=
"../TclLib/OpenFileChnl.htm">Tcl_RegisterChannel</a></b>, described
below. If one of the standard channels, <b>stdin, stdout</b> or
<b>stderr</b> was previously closed, the act of creating the new
channel also assigns it as a replacement for the standard
channel.</p>

<p><b>Tcl_FSGetCwd</b> replaces the library version of
getcwd().</p>

<p>It returns the Tcl library's current working directory. This may
be different to the native platform's working directory, in the
case for which the cwd is not in the native filesystem.</p>

<p>The result is a pointer to a Tcl_Obj specifying the current
directory, or NULL if the current directory could not be
determined. If NULL is returned, an error message is left in the
interp's result. The result already has its refCount incremented
for the caller. When it is no longer needed, that refCount should
be decremented. This is needed for thread-safety purposes, to allow
multiple threads to access this and related functions, while
ensuring the results are always valid.</p>

<p><b>Tcl_FSChdir</b> replaces the library version of chdir(). The
path is normalized and then passed to the filesystem which claims
it. If that filesystem does not implement this function, Tcl will
fallback to a combination of stat and access to check whether the
directory exists and has appropriate permissions.</p>

<p>For results, see chdir() documentation. If successful, we keep a
record of the successful path in cwdPathPtr for subsequent calls to
getcwd.</p>

<p><b>Tcl_FSPathSeparator</b> returns the separator character to be
used for most specific element of the path specified by pathPtr
(i.e. the last part of the path).</p>

<p>The separator is returned as a Tcl_Obj containing a string of
length 1. If the path is invalid, NULL is returned.</p>

<p><b>Tcl_FSJoinPath</b> takes the given Tcl_Obj, which should be a
valid list, and returns the path object given by considering the
first 'elements' elements as valid path segments. If elements &lt;
0, we use the entire list.</p>

<p>Returns object with refCount of zero, containing the joined
path.</p>

<p><b>Tcl_FSSplitPath</b> takes the given Tcl_Obj, which should be
a valid path, and returns a Tcl List object containing each segment
of that path as an element.</p>

<p>Returns list object with refCount of zero. If the passed in
lenPtr is non-NULL, we use it to return the number of elements in
the returned list.</p>

<p><b>Tcl_FSEqualPaths</b> tests whether the two paths given
represent the same filesystem object</p>

<p>It returns 1 if the paths are equal, and 0 if they are
different. If either path is NULL, 0 is always returned.</p>

<p><b>Tcl_FSGetNormalizedPath</b> this important function attempts
to extract from the given Tcl_Obj a unique normalized path
representation, whose string value can be used as a unique
identifier for the file.</p>

<p>It returns the normalized path object, with refCount of zero, or
NULL if the path was invalid or could otherwise not be successfully
converted. Extraction of absolute, normalized paths is very
efficient (because the filesystem operates on these representations
internally), although the result when the filesystem contains
numerous symbolic links may not be the most user-friendly version
of a path.</p>

<p><b>Tcl_FSJoinToPath</b> takes the given object, which should
usually be a valid path or NULL, and joins onto it the array of
paths segments given.</p>

<p>Returns object with refCount of zero, containing the joined
path.</p>

<p><b>Tcl_FSConvertToPathType</b> tries to convert the given
Tcl_Obj to a valid Tcl path type, taking account of the fact that
the cwd may have changed even if this object is already supposedly
of the correct type. The filename may begin with "~" (to indicate
current user's home directory) or "~&lt;user&gt;" (to indicate any
user's home directory).</p>

<p>If the conversion succeeds (i.e. the object is a valid path in
one of the current filesystems), then TCL_OK is returned. Otherwise
TCL_ERROR is returned, and an error message may be left in the
interpreter.</p>

<p><b>Tcl_FSGetInternalRep</b> extracts the internal representation
of a given path object, in the given filesystem. If the path object
belongs to a different filesystem, we return NULL. If the internal
representation is currently NULL, we attempt to generate it, by
calling the filesystem's <b>Tcl_FSCreateInternalRepProc</b>.</p>

<p>Returns NULL or a valid internal path representation. This
internal representation is cached, so that repeated calls to this
function will not require additional conversions.</p>

<p><b>Tcl_FSGetTranslatedPath</b> attempts to extract the
translated path from the given Tcl_Obj.</p>

<p>If the translation succeeds (i.e. the object is a valid path),
then it is returned. Otherwise NULL will be returned, and an error
message may be left in the interpreter. A "translated" path is one
which contains no "~" or "~user" sequences (these have been
expanded to their current representation in the filesystem).</p>

<p><b>Tcl_FSGetTranslatedStringPath</b> does the same as
<b>Tcl_FSGetTranslatedPath</b>, but returns a character string or
NULL.</p>

<p><b>Tcl_FSNewNativePath</b> performs something like that reverse
of the usual obj-&gt;path-&gt;nativerep conversions. If some code
retrieves a path in native form (from, e.g. readlink or a native
dialog), and that path is to be used at the Tcl level, then calling
this function is an efficient way of creating the appropriate path
object type.</p>

<p>The resulting object is a pure 'path' object, which will only
receive a Utf-8 string representation if that is required by some
Tcl code.</p>

<p><b>Tcl_FSGetNativePath</b> is for use by the Win/Unix/MacOS
native filesystems, so that they can easily retrieve the native
(char* or TCHAR*) representation of a path. This function is a
convenience wrapper around <b>Tcl_FSGetInternalRep</b>, and assumes
the native representation is string-based. It may be desirable in
the future to have non-string-based native representations (for
example, on MacOS, a representation using a fileSpec of FSRef
structure would probably be more efficient). On Windows a full
Unicode representation would allow for paths of unlimited length.
Currently the representation is simply a character string
containing the complete, absolute path in the native encoding.</p>

<p>The native representation is cached so that repeated calls to
this function will not require additional conversions.</p>

<p><b>Tcl_FSFileSystemInfo</b> returns a list of two elements. The
first element is the name of the filesystem (e.g. "native" or "vfs"
or "zip" or "prowrap", perhaps), and the second is the particular
type of the given path within that filesystem (which is filesystem
dependent). The second element may be empty if the filesystem does
not provide a further categorization of files.</p>

<p>A valid list object is returned, unless the path object is not
recognized, when NULL will be returned.</p>

<p><b>Tcl_FSGetFileSystemForPath</b> returns the a pointer to the
<b>Tcl_Filesystem</b> which accepts this path as valid.</p>

<p>If no filesystem will accept the path, NULL is returned.</p>

<p><b>Tcl_FSGetPathType</b> determines whether the given path is
relative to the current directory, relative to the current volume,
or absolute.</p>

<p>It returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
TCL_PATH_VOLUME_RELATIVE</p>

<p><b>Tcl_AllocStatBuf</b> allocates a <i>Tcl_StatBuf</i> on the
system heap (which may be deallocated by being passed to <b><a
href="../TclLib/Alloc.htm">ckfree</a></b>.) This allows extensions
to invoke <b>Tcl_FSStat</b> and <b>Tcl_FSLStat</b> without being
dependent on the size of the buffer. That in turn depends on the
flags used to build Tcl.</p>

<h3><a name="M6">TCL_FILESYSTEM</a></h3>

<p>A filesystem provides a <b>Tcl_Filesystem</b> structure that
contains pointers to functions that implement the various
operations on a filesystem; these operations are invoked as needed
by the generic layer, which generally occurs through the functions
listed above.</p>

<p>The <b>Tcl_Filesystem</b> structures are manipulated using the
following methods.</p>

<p><b>Tcl_FSRegister</b> takes a pointer to a filesystem structure
and an optional piece of data to associated with that filesystem.
On calling this function, Tcl will attach the filesystem to the
list of known filesystems, and it will become fully functional
immediately. Tcl does not check if the same filesystem is
registered multiple times (and in general that is not a good thing
to do). TCL_OK will be returned.</p>

<p><b>Tcl_FSUnregister</b> removes the given filesystem structure
from the list of known filesystems, if it is known, and returns
TCL_OK. If the filesystem is not currently registered, TCL_ERROR is
returned.</p>

<p><b>Tcl_FSData</b> will return the ClientData associated with the
given filesystem, if that filesystem is registered. Otherwise it
will return NULL.</p>

<p><b>Tcl_FSMountsChanged</b> is used to inform the Tcl's core that
the set of mount points for the given (already registered)
filesystem have changed, and that cached file representations may
therefore no longer be correct.</p>

<p>The <b>Tcl_Filesystem</b> structure contains the following
fields:</p>

<pre>
typedef struct Tcl_Filesystem {
    CONST char *<i>typeName</i>;  
    int <i>structureLength</i>;   
    Tcl_FSVersion <i>version</i>;  
    Tcl_FSPathInFilesystemProc *<i>pathInFilesystemProc</i>;
    Tcl_FSDupInternalRepProc *<i>dupInternalRepProc</i>;
    Tcl_FSFreeInternalRepProc *<i>freeInternalRepProc</i>;
    Tcl_FSInternalToNormalizedProc *<i>internalToNormalizedProc</i>;
    Tcl_FSCreateInternalRepProc *<i>createInternalRepProc</i>;
    Tcl_FSNormalizePathProc *<i>normalizePathProc</i>;       
    Tcl_FSFilesystemPathTypeProc *<i>filesystemPathTypeProc</i>;
    Tcl_FSFilesystemSeparatorProc *<i>filesystemSeparatorProc</i>;
    Tcl_FSStatProc *<i>statProc</i>; 
    Tcl_FSAccessProc *<i>accessProc</i>;        
    Tcl_FSOpenFileChannelProc *<i>openFileChannelProc</i>; 
    Tcl_FSMatchInDirectoryProc *<i>matchInDirectoryProc</i>;  
    Tcl_FSUtimeProc *<i>utimeProc</i>;       
    Tcl_FSLinkProc *<i>linkProc</i>; 
    Tcl_FSListVolumesProc *<i>listVolumesProc</i>;      
    Tcl_FSFileAttrStringsProc *<i>fileAttrStringsProc</i>;
    Tcl_FSFileAttrsGetProc *<i>fileAttrsGetProc</i>;
    Tcl_FSFileAttrsSetProc *<i>fileAttrsSetProc</i>;
    Tcl_FSCreateDirectoryProc *<i>createDirectoryProc</i>;      
    Tcl_FSRemoveDirectoryProc *<i>removeDirectoryProc</i>;      
    Tcl_FSDeleteFileProc *<i>deleteFileProc</i>;        
    Tcl_FSCopyFileProc *<i>copyFileProc</i>; 
    Tcl_FSRenameFileProc *<i>renameFileProc</i>;        
    Tcl_FSCopyDirectoryProc *<i>copyDirectoryProc</i>;      
    Tcl_FSLstatProc *<i>lstatProc</i>;      
    Tcl_FSLoadFileProc *<i>loadFileProc</i>; 
    Tcl_FSGetCwdProc *<i>getCwdProc</i>;     
    Tcl_FSChdirProc *<i>chdirProc</i>;      
} Tcl_Filesystem;
</pre>

<p>Except for the first three fields in this structure which
contain simple data elements, all entries contain addresses of
functions called by the generic filesystem layer to perform the
complete range of filesystem related actions.</p>

<p>The many functions in this structure are broken down into three
categories: infrastructure functions (almost all of which must be
implemented), operational functions (which must be implemented if a
complete filesystem is provided), and efficiency functions (which
need only be implemented if they can be done so efficiently, or if
they have side-effects which are required by the filesystem; Tcl
has less efficient emulations it can fall back on). It is important
to note that, in the current version of Tcl, most of these
fallbacks are only used to handle commands initiated in Tcl, not in
C. What this means is, that if a 'file rename' command is issued in
Tcl, and the relevant filesystem(s) do not implement their
<i>Tcl_FSRenameFileProc</i>, Tcl's core will instead fallback on a
combination of other filesystem functions (it will use
<i>Tcl_FSCopyFileProc</i> followed by <i>Tcl_FSDeleteFileProc</i>,
and if <i>Tcl_FSCopyFileProc</i> is not implemented there is a
further fallback). However, if a <i>Tcl_FSRenameFile</i> command is
issued at the C level, no such fallbacks occur. This is true except
for the last four entries in the filesystem table (lstat, load,
getcwd and chdir) for which fallbacks do in fact occur at the C
level.</p>

<p>As an example, here is the filesystem lookup table used by the
"vfs" extension which allows filesystem actions to be implemented
in Tcl.</p>

<pre>
static Tcl_Filesystem vfsFilesystem = {
    "tclvfs",
    sizeof(Tcl_Filesystem),
    TCL_FILESYSTEM_VERSION_1,
    &amp;VfsPathInFilesystem,
    &amp;VfsDupInternalRep,
    &amp;VfsFreeInternalRep,
    /* No internal to normalized, since we don't create any
     * pure 'internal' Tcl_Obj path representations */
    NULL,
    /* No create native rep function, since we don't use it
     * and don't choose to support uses of 'Tcl_FSNewNativePath' */
    NULL,
    /* Normalize path isn't needed - we assume paths only have
     * one representation */
    NULL,
    &amp;VfsFilesystemPathType,
    &amp;VfsFilesystemSeparator,
    &amp;VfsStat,
    &amp;VfsAccess,
    &amp;VfsOpenFileChannel,
    &amp;VfsMatchInDirectory,
    &amp;VfsUtime,
    /* We choose not to support symbolic links inside our vfs's */
    NULL,
    &amp;VfsListVolumes,
    &amp;VfsFileAttrStrings,
    &amp;VfsFileAttrsGet,
    &amp;VfsFileAttrsSet,
    &amp;VfsCreateDirectory,
    &amp;VfsRemoveDirectory, 
    &amp;VfsDeleteFile,
    /* No copy file - fallback will occur at Tcl level */
    NULL,
    /* No rename file - fallback will occur at Tcl level */
    NULL,
    /* No copy directory - fallback will occur at Tcl level */
    NULL, 
    /* Core will use stat for lstat */
    NULL,
    /* No load - fallback on core implementation */
    NULL,
    /* We don't need a getcwd or chdir - fallback on Tcl's versions */
    NULL,
    NULL
};
</pre>

<p>Any functions which take path names in Tcl_Obj form take those
names in UTF-8 form. The filesystem infrastructure API is designed
to support efficient, cached conversion of these UTF-8 paths to
other native representations.</p>

<h3><a name="M7">TYPENAME</a></h3>

<p>The <i>typeName</i> field contains a null-terminated string that
identifies the type of the filesystem implemented, e.g.
<b>native</b> or <b>zip</b> or <b>vfs</b>.</p>

<h3><a name="M8">STRUCTURE LENGTH</a></h3>

<p>The <i>structureLength</i> field is generally implemented as
<i>sizeof(Tcl_Filesystem)</i>, and is there to allow easier binary
backwards compatibility if the size of the structure changes in a
future Tcl release.</p>

<h3><a name="M9">VERSION</a></h3>

<p>The <i>version</i> field should be set to
<b>TCL_FILESYSTEM_VERSION_1</b>.</p>

<h3><a name="M10">FILESYSTEM INFRASTRUCTURE</a></h3>

<p>These fields contain addresses of functions which are used to
associate a particular filesystem with a file path, and deal with
the internal handling of path representations, for example copying
and freeing such representations.</p>

<h3><a name="M11">PATHINFILESYSTEMPROC</a></h3>

<p>The <i>pathInFilesystemProc</i> field contains the address of a
function which is called to determine whether a given path object
belongs to this filesystem or not. Tcl will only call the rest of
the filesystem functions with a path for which this function has
returned <b>TCL_OK</b>. If the path does not belong,
<b>TCL_ERROR</b> should be returned. If <b>TCL_OK</b> is returned,
then the optional <b>clientDataPtr</b> output parameter can be used
to return an internal (filesystem specific) representation of the
path, which will be cached inside the path object, and may be
retrieved efficiently by the other filesystem functions. Tcl will
simultaneously cache the fact that this path belongs to this
filesystem. Such caches are invalidated when filesystem structures
are added or removed from Tcl's internal list of known
filesystems.</p>

<pre>
typedef int Tcl_FSPathInFilesystemProc(
    Tcl_Obj *<i>pathPtr</i>, 
    ClientData *<i>clientDataPtr</i>);
</pre>

<h3><a name="M12">DUPINTERNALREPPROC</a></h3>

<p>This function makes a copy of a path's internal representation,
and is called when Tcl needs to duplicate a path object. If NULL,
Tcl will simply not copy the internal representation, which may
then need to be regenerated later.</p>

<pre>
typedef ClientData Tcl_FSDupInternalRepProc(
    ClientData <i>clientData</i>);
</pre>

<h3><a name="M13">FREEINTERNALREPPROC</a></h3>

<p>Free the internal representation. This must be implemented if
internal representations need freeing (i.e. if some memory is
allocated when an internal representation is generated), but may
otherwise be NULL.</p>

<pre>
typedef void Tcl_FSFreeInternalRepProc(
    ClientData <i>clientData</i>);
</pre>

<h3><a name="M14">INTERNALTONORMALIZEDPROC</a></h3>

<p>Function to convert internal representation to a normalized
path. Only required if the filesystem creates pure path objects
with no string/path representation. The return value is a Tcl
object whose string representation is the normalized path.</p>

<pre>
typedef Tcl_Obj* Tcl_FSInternalToNormalizedProc(
    ClientData <i>clientData</i>);
</pre>

<h3><a name="M15">CREATEINTERNALREPPROC</a></h3>

<p>Function to take a path object, and calculate an internal
representation for it, and store that native representation in the
object. May be NULL if paths have no internal representation, or if
the <i>Tcl_FSPathInFilesystemProc</i> for this filesystem always
immediately creates an internal representation for paths it
accepts.</p>

<pre>
typedef ClientData Tcl_FSCreateInternalRepProc(
    Tcl_Obj *<i>pathPtr</i>);
</pre>

<h3><a name="M16">NORMALIZEPATHPROC</a></h3>

<p>Function to normalize a path. Should be implemented for all
filesystems which can have multiple string representations for the
same path object. In Tcl, every 'path' must have a single unique
'normalized' string representation. Depending on the filesystem,
there may be more than one unnormalized string representation which
refers to that path (e.g. a relative path, a path with different
character case if the filesystem is case insensitive, a path
contain a reference to a home directory such as '~', a path
containing symbolic links, etc). If the very last component in the
path is a symbolic link, it should not be converted into the object
it points to (but its case or other aspects should be made unique).
All other path components should be converted from symbolic links.
This one exception is required to agree with Tcl's semantics with
'file delete', 'file rename', 'file copy' operating on symbolic
links. This function may be called with 'nextCheckpoint' either at
the beginning of the path (i.e. zero), at the end of the path, or
at any intermediate file separator in the path. It will never point
to any other arbitrary position in the path. In the last of the
three valid cases, the implementation can assume that the path up
to and including the file separator is known and normalized.</p>

<pre>
typedef int Tcl_FSNormalizePathProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>, 
    Tcl_Obj *<i>pathPtr</i>, 
    int <i>nextCheckpoint</i>);
</pre>

<h3><a name="M17">FILESYSTEM OPERATIONS</a></h3>

<p>The fields in this section of the structure contain addresses of
functions which are called to carry out the basic filesystem
operations. A filesystem which expects to be used with the complete
standard Tcl command set must implement all of these. If some of
them are not implemented, then certain Tcl commands may fail when
operating on paths within that filesystem. However, in some
instances this may be desirable (for example, a read-only
filesystem should not implement the last four functions, and a
filesystem which does not support symbolic links need not implement
the <b>readlink</b> function, etc. The Tcl core expects filesystems
to behave in this way).</p>

<h3><a name="M18">FILESYSTEMPATHTYPEPROC</a></h3>

<p>Function to determine the type of a path in this filesystem. May
be NULL, in which case no type information will be available to
users of the filesystem. The 'type' is used only for informational
purposes, and should be returned as the string representation of
the Tcl_Obj which is returned. A typical return value might be
"networked", "zip" or "ftp". The Tcl_Obj result is owned by the
filesystem and so Tcl will increment the refCount of that object if
it wishes to retain a reference to it.</p>

<pre>
typedef Tcl_Obj* Tcl_FSFilesystemPathTypeProc(
    Tcl_Obj *<i>pathPtr</i>);
</pre>

<h3><a name="M19">FILESYSTEMSEPARATORPROC</a></h3>

<p>Function to return the separator character(s) for this
filesystem. Must be implemented, otherwise the <b><a href=
"../TclCmd/file.htm">file separator</a></b> command will not
function correctly. The usual return value will be a Tcl_Obj
containing the string "/".</p>

<pre>
typedef Tcl_Obj* Tcl_FSFilesystemSeparatorProc(
    Tcl_Obj *<i>pathPtr</i>);
</pre>

<h3><a name="M20">STATPROC</a></h3>

<p>Function to process a <b>Tcl_FSStat()</b> call. Must be
implemented for any reasonable filesystem, since many Tcl level
commands depend crucially upon it (e.g. <b><a href=
"../TclCmd/file.htm">file atime</a></b>, <b><a href=
"../TclCmd/file.htm">file isdirectory</a></b>, <b><a href=
"../TclCmd/file.htm">file size</a></b>, <b><a href=
"../TclCmd/glob.htm">glob</a></b>).</p>

<pre>
typedef int Tcl_FSStatProc(
    Tcl_Obj *<i>pathPtr</i>,
    Tcl_StatBuf *<i>statPtr</i>);
</pre>

<p>The <b>Tcl_FSStatProc</b> fills the stat structure
<i>statPtr</i> with information about the specified file. You do
not need any access rights to the file to get this information but
you need search rights to all directories named in the path leading
to the file. The stat structure includes info regarding device,
inode (always 0 on Windows), privilege mode, nlink (always 1 on
Windows), user id (always 0 on Windows), group id (always 0 on
Windows), rdev (same as device on Windows), size, last access time,
last modification time, and creation time.</p>

<p>If the file represented by <i>pathPtr</i> exists, the
<b>Tcl_FSStatProc</b> returns 0 and the stat structure is filled
with data. Otherwise, -1 is returned, and no stat info is
given.</p>

<h3><a name="M21">ACCESSPROC</a></h3>

<p>Function to process a <b>Tcl_FSAccess()</b> call. Must be
implemented for any reasonable filesystem, since many Tcl level
commands depend crucially upon it (e.g. <b><a href=
"../TclCmd/file.htm">file exists</a></b>, <b><a href=
"../TclCmd/file.htm">file readable</a></b>).</p>

<pre>
typedef int Tcl_FSAccessProc(
    Tcl_Obj *<i>pathPtr</i>,
    int <i>mode</i>);
</pre>

<p>The <b>Tcl_FSAccessProc</b> checks whether the process would be
allowed to read, write or test for existence of the file (or other
file system object) whose name is pathname. If pathname is a
symbolic link, then permissions of the file referred by this
symbolic link should be tested.</p>

<p>On success (all requested permissions granted), zero is
returned. On error (at least one bit in mode asked for a permission
that is denied, or some other error occurred), -1 is returned.</p>

<h3><a name="M22">OPENFILECHANNELPROC</a></h3>

<p>Function to process a <b>Tcl_FSOpenFileChannel()</b> call. Must
be implemented for any reasonable filesystem, since any operations
which require open or accessing a file's contents will use it (e.g.
<b><a href="../TclCmd/open.htm">open</a></b>, <b><a href=
"../TclCmd/encoding.htm">encoding</a></b>, and many Tk
commands).</p>

<pre>
typedef Tcl_Channel Tcl_FSOpenFileChannelProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>,
    Tcl_Obj *<i>pathPtr</i>,
    int <i>mode</i>,
    int <i>permissions</i>);
</pre>

<p>The <b>Tcl_FSOpenFileChannelProc</b> opens a file specified by
<i>pathPtr</i> and returns a channel handle that can be used to
perform input and output on the file. This API is modeled after the
<b>fopen</b> procedure of the Unix standard I/O library. The syntax
and meaning of all arguments is similar to those given in the Tcl
<b><a href="../TclCmd/open.htm">open</a></b> command when opening a
file, where the <i>mode</i> argument is a combination of the POSIX
flags O_RDONLY, O_WRONLY, etc. If an error occurs while opening the
channel, the <b>Tcl_FSOpenFileChannelProc</b> returns NULL and
records a POSIX error code that can be retrieved with <b><a href=
"../TclLib/SetErrno.htm">Tcl_GetErrno</a></b>. In addition, if
<i>interp</i> is non-NULL, the <b>Tcl_FSOpenFileChannelProc</b>
leaves an error message in <i>interp</i>'s result after any
error.</p>

<p>The newly created channel is not registered in the supplied
interpreter; to register it, use <b><a href=
"../TclLib/OpenFileChnl.htm">Tcl_RegisterChannel</a></b>. If one of
the standard channels, <b>stdin, stdout</b> or <b>stderr</b> was
previously closed, the act of creating the new channel also assigns
it as a replacement for the standard channel.</p>

<h3><a name="M23">MATCHINDIRECTORYPROC</a></h3>

<p>Function to process a <b>Tcl_FSMatchInDirectory()</b> call. If
not implemented, then glob and recursive copy functionality will be
lacking in the filesystem (and this may impact commands like
'encoding names' which use glob functionality internally).</p>

<pre>
typedef int Tcl_FSMatchInDirectoryProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a>* <i>interp</i>, 
    Tcl_Obj *<i>result</i>,
    Tcl_Obj *<i>pathPtr</i>, 
    CONST char *<i>pattern</i>, 
    Tcl_GlobTypeData * <i>types</i>);
</pre>

<p>The function should return all files or directories (or other
filesystem objects) which match the given pattern and accord with
the <i>types</i> specification given. There are two ways in which
this function may be called. If <i>pattern</i> is NULL, then
<i>pathPtr</i> is a full path specification of a single file or
directory which should be checked for existence and correct type.
Otherwise, <i>pathPtr</i> is a directory, the contents of which the
function should search for files or directories which have the
correct type. In either case, <i>pathPtr</i> can be assumed to be
both non-NULL and non-empty. It is not currently documented whether
<i>pathPtr</i> will have a file separator at its end of not, so
code should be flexible to both possibilities.</p>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the matching process. Error messages are placed
in interp, but on a TCL_OK result, the interpreter should not be
modified, but rather results should be added to the <i>result</i>
object given (which can be assumed to be a valid Tcl list). The
matches added to <i>result</i> should include any path prefix given
in <i>pathPtr</i> (this usually means they will be absolute path
specifications). Note that if no matches are found, that simply
leads to an empty result --- errors are only signaled for actual
file or filesystem problems which may occur during the matching
process.</p>

<h3><a name="M24">UTIMEPROC</a></h3>

<p>Function to process a <b>Tcl_FSUtime()</b> call. Required to
allow setting (not reading) of times with 'file mtime', 'file
atime' and the open-r/open-w/fcopy implementation of 'file
copy'.</p>

<pre>
typedef int Tcl_FSUtimeProc(
    Tcl_Obj *<i>pathPtr</i>, 
    struct utimbuf *<i>tval</i>);
</pre>

<p>The access and modification times of the file specified by
<i>pathPtr</i> should be changed to the values given in the
<i>tval</i> structure.</p>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the process.</p>

<h3><a name="M25">LINKPROC</a></h3>

<p>Function to process a <b>Tcl_FSLink()</b> call. Should be
implemented only if the filesystem supports links, and may
otherwise be NULL.</p>

<pre>
typedef Tcl_Obj* Tcl_FSLinkProc(
    Tcl_Obj *<i>linkNamePtr</i>,
    Tcl_Obj *<i>toPtr</i>,
    int <i>linkAction</i>);
</pre>

<p>If <i>toPtr</i> is NULL, the function is being asked to read the
contents of a link. The result is a Tcl_Obj specifying the contents
of the link given by <i>linkNamePtr</i>, or NULL if the link could
not be read. The result is owned by the caller, which should call
<a href="../TclLib/Object.htm">Tcl_DecrRefCount</a> when the result
is no longer needed. If <i>toPtr</i> is not NULL, the function
should attempt to create a link. The result in this case should be
<i>toPtr</i> if the link was successful and NULL otherwise. In this
case the result is not owned by the caller. See the documentation
for <b>Tcl_FSLink</b> for the correct interpretation of the
<i>linkAction</i> flags.</p>

<h3><a name="M26">LISTVOLUMESPROC</a></h3>

<p>Function to list any filesystem volumes added by this
filesystem. Should be implemented only if the filesystem adds
volumes at the head of the filesystem, so that they can be returned
by 'file volumes'.</p>

<pre>
typedef Tcl_Obj* Tcl_FSListVolumesProc(void);
</pre>

<p>The result should be a list of volumes added by this filesystem,
or NULL (or an empty list) if no volumes are provided. The result
object is considered to be owned by the filesystem (not by Tcl's
core), but should be given a refCount for Tcl. Tcl will use the
contents of the list and then decrement that refCount. This allows
filesystems to choose whether they actually want to retain a
'master list' of volumes or not (if not, they generate the list on
the fly and pass it to Tcl with a refCount of 1 and then forget
about the list, if yes, then they simply increment the refCount of
their master list and pass it to Tcl which will copy the contents
and then decrement the count back to where it was).</p>

<p>Therefore, Tcl considers return values from this proc to be
read-only.</p>

<h3><a name="M27">FILEATTRSTRINGSPROC</a></h3>

<p>Function to list all attribute strings which are valid for this
filesystem. If not implemented the filesystem will not support the
<b><a href="../TclCmd/file.htm">file attributes</a></b> command.
This allows arbitrary additional information to be attached to
files in the filesystem. If it is not implemented, there is no need
to implement the <b>get</b> and <b><a href=
"../TclCmd/set.htm">set</a></b> methods.</p>

<pre>
typedef CONST char** Tcl_FSFileAttrStringsProc(
    Tcl_Obj *<i>pathPtr</i>, 
    Tcl_Obj** <i>objPtrRef</i>);
</pre>

<p>The called function may either return an array of strings, or
may instead return NULL and place a Tcl list into the given
objPtrRef. Tcl will take that list and first increment its refCount
before using it. On completion of that use, Tcl will decrement its
refCount. Hence if the list should be disposed of by Tcl when done,
it should have a refCount of zero, and if the list should not be
disposed of, the filesystem should ensure it retains a refCount on
the object.</p>

<h3><a name="M28">FILEATTRSGETPROC</a></h3>

<p>Function to process a <b>Tcl_FSFileAttrsGet()</b> call, used by
'file attributes'.</p>

<pre>
typedef int Tcl_FSFileAttrsGetProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>,
    int <i>index</i>, 
    Tcl_Obj *<i>pathPtr</i>,
    Tcl_Obj **<i>objPtrRef</i>);
</pre>

<p>Returns a standard Tcl return code. The attribute value
retrieved, which corresponds to the <i>index</i>'th element in the
list returned by the Tcl_FSFileAttrStringsProc, is a Tcl_Obj placed
in objPtrRef (if TCL_OK was returned) and is likely to have a
refCount of zero. Either way we must either store it somewhere
(e.g. the Tcl result), or Incr/Decr its refCount to ensure it is
properly freed.</p>

<h3><a name="M29">FILEATTRSSETPROC</a></h3>

<p>Function to process a <b>Tcl_FSFileAttrsSet()</b> call, used by
'file attributes'. If the filesystem is read-only, there is no need
to implement this.</p>

<pre>
typedef int Tcl_FSFileAttrsSetProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>,
    int <i>index</i>, 
    Tcl_Obj *<i>pathPtr</i>,
    Tcl_Obj *<i>objPtr</i>);
</pre>

<p>The attribute value of the <i>index</i>'th element in the list
returned by the Tcl_FSFileAttrStringsProc should be set to the
<i>objPtr</i> given.</p>

<h3><a name="M30">CREATEDIRECTORYPROC</a></h3>

<p>Function to process a <b>Tcl_FSCreateDirectory()</b> call.
Should be implemented unless the FS is read-only.</p>

<pre>
typedef int Tcl_FSCreateDirectoryProc(
    Tcl_Obj *<i>pathPtr</i>);
</pre>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the process. If successful, a new directory
should have been added to the filesystem in the location specified
by <i>pathPtr</i>.</p>

<h3><a name="M31">REMOVEDIRECTORYPROC</a></h3>

<p>Function to process a 'Tcl_FSRemoveDirectory()' call. Should be
implemented unless the FS is read-only.</p>

<pre>
typedef int Tcl_FSRemoveDirectoryProc(
    Tcl_Obj *<i>pathPtr</i>,
    int <i>recursive</i>, 
    Tcl_Obj **<i>errorPtr</i>);
</pre>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the process. If successful, the directory
specified by <i>pathPtr</i> should have been removed from the
filesystem. If the <i>recursive</i> flag is given, then a non-empty
directory should be deleted without error. If an error does occur,
the name of the file or directory which caused the error should be
placed in <i>errorPtr</i>.</p>

<h3><a name="M32">DELETEFILEPROC</a></h3>

<p>Function to process a <b>Tcl_FSDeleteFile()</b> call. Should be
implemented unless the FS is read-only.</p>

<pre>
typedef int Tcl_FSDeleteFileProc(
    Tcl_Obj *<i>pathPtr</i>);
</pre>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the process. If successful, the file specified by
<i>pathPtr</i> should have been removed from the filesystem. Note
that, if the filesystem supports symbolic links, Tcl will always
call this function and not Tcl_FSRemoveDirectoryProc when needed to
delete them (even if they are symbolic links to directories).</p>

<h3><a name="M33">FILESYSTEM EFFICIENCY</a></h3>

<h3><a name="M34">LSTATPROC</a></h3>

<p>Function to process a <b>Tcl_FSLstat()</b> call. If not
implemented, Tcl will attempt to use the <i>statProc</i> defined
above instead. Therefore it need only be implemented if a
filesystem can differentiate between <b>stat</b> and <b>lstat</b>
calls.</p>

<pre>
typedef int Tcl_FSLstatProc(
    Tcl_Obj *<i>pathPtr</i>, 
    Tcl_StatBuf *<i>statPtr</i>);
</pre>

<p>The behavior of this function is very similar to that of the
Tcl_FSStatProc defined above, except that if it is applied to a
symbolic link, it returns information about the link, not about the
target file.</p>

<h3><a name="M35">COPYFILEPROC</a></h3>

<p>Function to process a <b>Tcl_FSCopyFile()</b> call. If not
implemented Tcl will fall back on open-r, open-w and fcopy as a
copying mechanism. Therefore it need only be implemented if the
filesystem can perform that action more efficiently.</p>

<pre>
typedef int Tcl_FSCopyFileProc(
    Tcl_Obj *<i>srcPathPtr</i>,
    Tcl_Obj *<i>destPathPtr</i>);
</pre>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the copying process. Note that,
<i>destPathPtr</i> is the name of the file which should become the
copy of <i>srcPathPtr</i>. It is never the name of a directory into
which <i>srcPathPtr</i> could be copied (i.e. the function is much
simpler than the Tcl level 'file copy' subcommand). Note that, if
the filesystem supports symbolic links, Tcl will always call this
function and not Tcl_FSCopyDirectoryProc when needed to copy them
(even if they are symbolic links to directories).</p>

<h3><a name="M36">RENAMEFILEPROC</a></h3>

<p>Function to process a <b>Tcl_FSRenameFile()</b> call. If not
implemented, Tcl will fall back on a copy and delete mechanism.
Therefore it need only be implemented if the filesystem can perform
that action more efficiently.</p>

<pre>
typedef int Tcl_FSRenameFileProc(
    Tcl_Obj *<i>srcPathPtr</i>,
    Tcl_Obj *<i>destPathPtr</i>);
</pre>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the renaming process.</p>

<h3><a name="M37">COPYDIRECTORYPROC</a></h3>

<p>Function to process a <b>Tcl_FSCopyDirectory()</b> call. If not
implemented, Tcl will fall back on a recursive create-dir, file
copy mechanism. Therefore it need only be implemented if the
filesystem can perform that action more efficiently.</p>

<pre>
typedef int Tcl_FSCopyDirectoryProc(
    Tcl_Obj *<i>srcPathPtr</i>,
    Tcl_Obj *<i>destPathPtr</i>, 
    Tcl_Obj **<i>errorPtr</i>);
</pre>

<p>The return value is a standard Tcl result indicating whether an
error occurred in the copying process. If an error does occur, the
name of the file or directory which caused the error should be
placed in <i>errorPtr</i>. Note that, <i>destPathPtr</i> is the
name of the directory-name which should become the mirror-image of
<i>srcPathPtr</i>. It is not the name of a directory into which
<i>srcPathPtr</i> should be copied (i.e. the function is much
simpler than the Tcl level 'file copy' subcommand).</p>

<h3><a name="M38">LOADFILEPROC</a></h3>

<p>Function to process a <b>Tcl_FSLoadFile()</b> call. If not
implemented, Tcl will fall back on a copy to native-temp followed
by a Tcl_FSLoadFile on that temporary copy. Therefore it need only
be implemented if the filesystem can load code directly, or it can
be implemented simply to return TCL_ERROR to disable load
functionality in this filesystem entirely.</p>

<pre>
typedef int Tcl_FSLoadFileProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a> * <i>interp</i>, 
    Tcl_Obj *<i>pathPtr</i>, 
    Tcl_LoadHandle * <i>handlePtr</i>,
    Tcl_FSUnloadFileProc * <i>unloadProcPtr</i>);
</pre>

<p>Returns a standard Tcl completion code. If an error occurs, an
error message is left in the interp's result. The function
dynamically loads a binary code file into memory. On a successful
load, the <i>handlePtr</i> should be filled with a token for the
dynamically loaded file, and the <i>unloadProcPtr</i> should be
filled in with the address of a procedure. The procedure will be
called with the given Tcl_LoadHandle as its only parameter when Tcl
needs to unload the file.</p>

<h3><a name="M39">UNLOADFILEPROC</a></h3>

<p>Function to unload a previously successfully loaded file. If
load was implemented, then this should also be implemented, if
there is any cleanup action required.</p>

<pre>
typedef void Tcl_FSUnloadFileProc(
    Tcl_LoadHandle <i>loadHandle</i>);
</pre>

<h3><a name="M40">GETCWDPROC</a></h3>

<p>Function to process a <b>Tcl_FSGetCwd()</b> call. Most
filesystems need not implement this. It will usually only be called
once, if 'getcwd' is called before 'chdir'. May be NULL.</p>

<pre>
typedef Tcl_Obj* Tcl_FSGetCwdProc(
    <a href="../TclLib/Interp.htm">Tcl_Interp</a> *<i>interp</i>);
</pre>

<p>If the filesystem supports a native notion of a current working
directory (which might perhaps change independent of Tcl), this
function should return that cwd as the result, or NULL if the
current directory could not be determined (e.g. the user does not
have appropriate permissions on the cwd directory). If NULL is
returned, an error message is left in the interp's result.</p>

<h3><a name="M41">CHDIRPROC</a></h3>

<p>Function to process a <b>Tcl_FSChdir()</b> call. If filesystems
do not implement this, it will be emulated by a series of directory
access checks. Otherwise, virtual filesystems which do implement it
need only respond with a positive return result if the dirName is a
valid, accessible directory in their filesystem. They need not
remember the result, since that will be automatically remembered
for use by GetCwd. Real filesystems should carry out the correct
action (i.e. call the correct system 'chdir' api).</p>

<pre>
typedef int Tcl_FSChdirProc(
    Tcl_Obj *<i>pathPtr</i>);
</pre>

<p>The <b>Tcl_FSChdirProc</b> changes the applications current
working directory to the value specified in <i>pathPtr</i>. The
function returns -1 on error or 0 on success.</p>

<h3><a name="M42">KEYWORDS</a></h3>

<p><a href="../Keywords/S.htm#stat access filesystem vfs">stat
access filesystem vfs</a></p>

<hr>
<pre>
<a href="../copyright.htm">Copyright</a> &copy; 2001 Vincent Darley
<a href=
"../copyright.htm">Copyright</a> &copy; 1995-1997 Roger E. Critchlow Jr.
</pre>
</body>
</html>

