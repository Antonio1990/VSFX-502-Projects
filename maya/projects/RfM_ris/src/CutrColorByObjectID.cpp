/* 
 CutrColorByObjectID.cpp
 Generated by Cutter from:
     "/home/mkesson/mount/fachome/maya/projects/RfM_ris/Args/CutrColorByObjectID.args"
 at 0.41:16pm 2.16.2016
*/
#include <RixPattern.h> 
#include <RixShadingUtils.h>
#include <RixShading.h>
#include <RixColorUtils.h>
#include <cstring>
#include <stdlib.h> /* srand(), rand() */

class CutrColorByObjectID : public RixPattern {
public:

    CutrColorByObjectID();
    virtual ~CutrColorByObjectID() { }
    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &) { }
    virtual int ComputeOutputParams(RixShadingContext const *ctx,
                                    RtInt *noutputs, 
                                    OutputSpec **outputs,
                                    RtConstPointer instanceData,
                                    RixSCParamInfo const *ignored);
	private:
		RixMessages *m_msg;
		RixShadeFunctions *m_shd;  // Shading functions in RixInterfaces.h
		RtColorRGB	m_rgb_1;
		RtColorRGB	m_rgb_2;
		RtInt		m_cycle;
		RtInt		m_do_random;
	};

CutrColorByObjectID::CutrColorByObjectID():
	m_msg(NULL),
	m_shd(NULL),
	m_rgb_1(1,1,0),
	m_rgb_2(1,0,1),
	m_cycle(100),
	m_do_random(0)
	{ }

int CutrColorByObjectID::Init(RixContext &ctx, char const *pluginpath) {
    m_msg = (RixMessages*)ctx.GetRixInterface(k_RixMessages);
    m_shd = (RixShadeFunctions*)ctx.GetRixInterface(k_RixShadeFunctions);

    // Uncomment the next three lines if a rib Option will be queried.
    //RixRenderState *rstate = (RixRenderState*)ctx.GetRixInterface(k_RixRenderState);
    //RixRenderState::Type optType;
    //RtInt optNumValues, err;
    // Example of using messaging,
    //    m_msg->Info("%f\n", a_float_value);
    return (!m_msg) ? 1 : 0;
    }

RixSCParamInfo const *CutrColorByObjectID::GetParamTable() {
    static RixSCParamInfo s_ptable[] = {
		// Output
		RixSCParamInfo("resultRGB", k_RixSCColor, k_RixSCOutput),
		// Inputs
		RixSCParamInfo("rgb_1", k_RixSCColor),
		RixSCParamInfo("rgb_2", k_RixSCColor),
		RixSCParamInfo("cycle", k_RixSCInteger),
		RixSCParamInfo("do_random", k_RixSCInteger),
		RixSCParamInfo() // end of table
        };
    return &s_ptable[0];
    }

enum paramIndex {
	k_resultRGB = 0,
	k_rgb_1,
	k_rgb_2,
	k_cycle,
	k_do_random
    };
	
int CutrColorByObjectID::ComputeOutputParams(RixShadingContext const *ctx,
								RtInt *noutputs, 
								OutputSpec **outputs,
								RtConstPointer instanceData,
								RixSCParamInfo const *ignored) {

	// Uncomment the next three lines if a rib Attribute will be queried. Note
	// that Rib Options should be queried in the init() method - not here!
	RixRenderState *rstate = (RixRenderState*)ctx->GetRixInterface(k_RixRenderState);
	RixRenderState::Type attrType;
	RtInt attrNumValues, err;

	// OUTPUTS BEGIN____________________________________
	// Allocate memory for the OutputSpec data structure.
	RixShadingContext::Allocator pool(ctx);
	OutputSpec *outSpec = pool.AllocForPattern<OutputSpec>(1);
	*outputs = outSpec;

	// Allocate memory for each output.
	RtColorRGB	*resultRGB = pool.AllocForPattern<RtColorRGB>(ctx->numPts);

	// Connect the output(s) to the OutputSpec.
	*noutputs = 1;
	outSpec[0].paramId = k_resultRGB;
	outSpec[0].detail = k_RixSCVarying;
	outSpec[0].value = resultRGB;

	// INPUTS BEGIN____________________________________
	bool varying = true;
	bool uniform = false;
	// Declare a pointer for each input then obtain their values
	// using EvalParam().
	RtColorRGB	const *rgb_1;
	RtColorRGB	const *rgb_2;
	RtInt		const *cyclePtr;
	RtInt		const *do_randomPtr;
	ctx->EvalParam(k_rgb_1, -1, &rgb_1, &m_rgb_1, varying);
	ctx->EvalParam(k_rgb_2, -1, &rgb_2, &m_rgb_2, varying);
	ctx->EvalParam(k_cycle, -1, &cyclePtr, &m_cycle, uniform);
	ctx->EvalParam(k_do_random, -1, &do_randomPtr, &m_do_random, uniform);

	RtFloat id;
	err = rstate->GetAttribute("identifier:id", &id, sizeof(RtFloat), &attrType, &attrNumValues);
	if(err != 0 || attrType != RixRenderState::k_Float) {
		id = 1.0; // default value ?
		}
	RtInt cycle = (*cyclePtr < 1) ? 1 : *cyclePtr;
	if(*do_randomPtr) {
		srand( (unsigned int)id );
		id = rand() % cycle + 1;
		}
	RtFloat blend = fmod(id/cycle, 1);
	//m_msg->Info("%f\n", blend);
	// Assign values to the output(s).
	for(int i = 0; i < ctx->numPts; i++) {
 		resultRGB[i] = RixMix(rgb_1[i], rgb_2[i], blend);
		}
	return 0;
	}
RIX_PATTERNCREATE {
	return new CutrColorByObjectID();
	}
RIX_PATTERNDESTROY {
	delete((CutrColorByObjectID*)pattern);
	}
