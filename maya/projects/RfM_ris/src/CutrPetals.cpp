/* 
 CutrPetals.cpp
 Generated by Cutter from:
     "/Users/malcolm/Documents/maya/projects/RfM_ris/Args/CutrPetals.args"
 at 2.24:6pm 4.3.2016
*/
#include <RixPattern.h> 
#include <RixShadingUtils.h>
#include <RixShading.h>
//#include <RixInterfaces.h>
#include <cstring>
#include <math.h>

class CutrPetals : public RixPattern {
public:

    CutrPetals();
    virtual ~CutrPetals() { }
    virtual int Init(RixContext &, char const *pluginpath);
    virtual RixSCParamInfo const *GetParamTable();
    virtual void Finalize(RixContext &) { }
    virtual int ComputeOutputParams(RixShadingContext const *ctx,
                                    RtInt *noutputs, 
                                    OutputSpec **outputs,
                                    RtConstPointer instanceData,
                                    RixSCParamInfo const *ignored);
	private:
		RixMessages *m_msg;
		RixShadeFunctions *m_shd;  // Shading functions in RixInterfaces.h
		RtFloat		m_petal_scale;
		RtFloat		m_petal_length;
		RtFloat		m_petal_width;
		RtFloat		m_stem_width;
		RtFloat		m_stem_length;
		RtInt		m_invert;
	};

CutrPetals::CutrPetals():
	m_msg(NULL),
	m_shd(NULL),
	m_petal_scale(1),
	m_petal_length(0.5),
	m_petal_width(0.5),
	m_stem_width(0.04),
	m_stem_length(0.5),
	m_invert(0)
	{ }

int CutrPetals::Init(RixContext &ctx, char const *pluginpath) {
    m_msg = (RixMessages*)ctx.GetRixInterface(k_RixMessages);
    m_shd = (RixShadeFunctions*)ctx.GetRixInterface(k_RixShadeFunctions);
    return (!m_msg) ? 1 : 0;
    }

RixSCParamInfo const *CutrPetals::GetParamTable() {
    static RixSCParamInfo s_ptable[] = {
		// Output
		RixSCParamInfo("resultF", k_RixSCFloat, k_RixSCOutput),
		// Inputs
		RixSCParamInfo("PxrManifold", "manifold", k_RixSCStructBegin),
		   RixSCParamInfo("Q", k_RixSCPoint),
		   RixSCParamInfo("Qradius", k_RixSCFloat),
		RixSCParamInfo("PxrManifold", "manifold", k_RixSCStructEnd),
		RixSCParamInfo("petal_scale", k_RixSCFloat),
		RixSCParamInfo("petal_length", k_RixSCFloat),
		RixSCParamInfo("petal_width", k_RixSCFloat),
		RixSCParamInfo("stem_width", k_RixSCFloat),
		RixSCParamInfo("stem_length", k_RixSCFloat),
		RixSCParamInfo("invert", k_RixSCInteger),
		RixSCParamInfo() // end of table
        };
    return &s_ptable[0];
    }

enum paramIndex {
	k_resultF = 0,
	k_manifold,
	    k_manifoldQ,
	    k_manifoldQradius,
	k_manifoldEnd,
	k_petal_scale,
	k_petal_length,
	k_petal_width,
	k_stem_width,
	k_stem_length,
	k_invert
    };
	
int CutrPetals::ComputeOutputParams(RixShadingContext const *ctx,
								RtInt *noutputs, 
								OutputSpec **outputs,
								RtConstPointer instanceData,
								RixSCParamInfo const *ignored) {

	// OUTPUTS BEGIN____________________________________
	// Allocate memory for the OutputSpec data structure.
	RixShadingContext::Allocator pool(ctx);
	OutputSpec *outSpec = pool.AllocForPattern<OutputSpec>(1);
	*outputs = outSpec;

	// Allocate memory for each output.
	RtFloat	*resultF = pool.AllocForPattern<RtFloat>(ctx->numPts);

	// Connect the output(s) to the OutputSpec.
	*noutputs = 1;
	outSpec[0].paramId = k_resultF;
	outSpec[0].detail = k_RixSCVarying;
	outSpec[0].value = resultF;

	// INPUTS BEGIN____________________________________
	bool varying = true;
	bool uniform = false;
	// Declare a pointer for each input then obtain their values
	// using EvalParam().
	RtFloat		const *petal_scale;
	RtFloat		const *petal_length;
	RtFloat		const *petal_width;
	RtFloat		const *stem_width;
	RtFloat		const *stem_length;
	RtInt		const *invertPtr;
	ctx->EvalParam(k_petal_scale, -1, &petal_scale, &m_petal_scale, varying);
	ctx->EvalParam(k_petal_length, -1, &petal_length, &m_petal_length, varying);
	ctx->EvalParam(k_petal_width, -1, &petal_width, &m_petal_width, varying);
	ctx->EvalParam(k_stem_width, -1, &stem_width, &m_stem_width, varying);
	ctx->EvalParam(k_stem_length, -1, &stem_length, &m_stem_length, varying);
	ctx->EvalParam(k_invert, -1, &invertPtr, &m_invert, uniform);

	// Prepare to read 'st' texture values from a connected manifold 
	// or from a 'st' primitive variable. 
	RixSCConnectionInfo cinfo;
	RixSCType type;
	RtPoint3 const *Q;
	RtFloat2 const *st, st_default(0,0);
	
	// Only if the manifold is connected can its Q[i].x and Q[i].y
	// texture coordinates be used.
	ctx->GetParamInfo(k_manifold, &type, &cinfo);
	if(cinfo == k_RixSCNetworkValue) 
		ctx->EvalParam(k_manifoldQ, -1, &Q);
	else
		ctx->GetPrimVar("st", st_default, &st);
	bool	isConnected = (cinfo == k_RixSCNetworkValue) ? true : false;
	int		row, col;
	float	x, y, s, t, tt, rad, dist, widthRatio, heightRatio,
			stem_w;
	
	// Assign values to the output(s).
	for(int i = 0; i < ctx->numPts; i++) {
		s = (isConnected) ? Q[i].x : st[i].x;
		t = (isConnected) ? Q[i].y : st[i].y;
		row = int(t);
		col = int(s);
		s = s - col;
		t = t - row;
		if(*invertPtr)
			t = 1 - t;
			
		tt = 1 - t ; // distances are now from "bottom" to "top"
		rad = petal_scale[i];
		widthRatio  = 1.0/(petal_width[i]);
		heightRatio = 1.0/(petal_length[i]);
		x = (s - 0.5) * widthRatio;
		y = (tt - stem_length[i] ) * heightRatio;
		dist = sqrt(x * x + y * y);
		
		stem_w = stem_width[i] * 0.5;
		if( dist <= rad || (s <= 0.5 + stem_w && s >= 0.5 - stem_w && tt < stem_length[i]) ) {
			resultF[i] = 1.0;
			}
		else
			{
			resultF[i] = 0.0;
			}
		}
	return 0;
	}
RIX_PATTERNCREATE {
	return new CutrPetals();
	}
RIX_PATTERNDESTROY {
	delete((CutrPetals*)pattern);
	}
